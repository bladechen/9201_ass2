diff --git .gitignore .gitignore
new file mode 100644
index 0000000..98d3998
--- /dev/null
+++ .gitignore
@@ -0,0 +1,43 @@
+# Object files
+*.o
+*.ko
+*.obj
+*.elf
+
+# Precompiled Headers
+*.gch
+*.pch
+
+# Libraries
+*.lib
+*.a
+*.la
+*.lo
+
+# Shared objects (inc. Windows DLLs)
+*.dll
+*.so
+*.so.*
+*.dylib
+
+# Executables
+*.exe
+*.out
+*.app
+*.i*86
+*.x86_64
+*.hex
+
+# Debug files
+*.dSYM/
+*.su
+build
+.depend
+defs.mk
+kern/compile/*
+*.o
+TAGS
+tags
+root
+.*project
+.settings
diff --git build_all.sh build_all.sh
new file mode 100755
index 0000000..4c4256c
--- /dev/null
+++ build_all.sh
@@ -0,0 +1,43 @@
+#!/bin/bash
+
+if [ $# -gt 1 ]; then
+    echo "Usage ./build_all.sh PATH/TO/ROOT"
+    exit 0
+fi
+
+current_path=`pwd`
+# If path is not supplied dont include --ostree
+if [ $# -eq 0 ]; then
+    SRC_PATH=~/cs3231/asst2-src
+    KERN_ROOT=~/cs3231/root
+    cd $SRC_PATH
+    ./configure
+# If path is not supplied include --ostree=path/to/root
+else
+    SRC_PATH=$current_path
+    KERN_ROOT=$SRC_PATH/../root
+    cd $SRC_PATH
+    ./configure --ostree=$KERN_ROOT
+    echo "Main PATH: $SRC_PATH"
+    echo "Kernal Root: $KERN_ROOT"
+fi
+
+echo "----------- Making Userland NOW -----------"
+# Confifure the kernel
+bmake
+bmake install
+bash $SRC_PATH/kern/build_kern.sh $SRC_PATH/kern
+
+echo "----------- Copying the gdbinit and conf files to root -----------"
+if [ ! -f $KERN_ROOT/.gdbinit ]
+then
+    cp $SRC_PATH/root_config/.gdbinit $KERN_ROOT/
+fi
+
+if [ ! -f $KERN_ROOT/sys161-asst2.conf ]
+then
+    cp $SRC_PATH/root_config/sys161-asst2.conf $KERN_ROOT/
+fi
+
+echo "----------- Finished Making Userland -----------"
+cd $current_path
diff --git design.txt design.txt
index c59d36d..f2b9c2a 100644
--- design.txt
+++ design.txt
@@ -1 +1,113 @@
-Place your design document here.
+********************************************
+*          Basic Issues
+********************************************
+
+
+1. Refering to manipulating files, there are several cases we should deal with ->
+
+    a. Process A fork process B, they should have seperated file descriptor table with exactly the same values in the table, but just after calling fork, they should share the vnode pointer which means they can interfere with each other while operating the files opened before fork.
+    b. in addition to case a, process B and process A could open the same files after fork, then manipulating that file should not interfere with each other.
+
+We design Open File Table layer(global) and File descriptor layer(per process) to deal with this issue.
+
+
+2. The open file table should support its entry referenced by different file descriptor, and if the reference count decrease to 0, it should be deleted; also there are race condition here while different process operating on the same entry in open file table.
+
+In order to achieve O(1) while deleting the entry, we use double linked list here. Also in order to make our code elegant, we add intrusive list which based on double linked list(refer to kern/include/file.h for details).
+we use atomic value for reference count to be elegant to avoid the race condition happened in vnode_decref/emufs_reclaim, because in vnode_decref, it decrease reference count, and then release the spinlock, and at this time the reference count maybe modified by other threads.
+
+
+3. In order to test whether the implementation is correct, I also write user level unit_test and kernel level multi-thread test, they are also included in the patch.
+
+
+********************************************
+*          Design Overview
+********************************************
+
+There are two parts of file system implemented in this assignment ->
+1. Open File Table layer, contains a global single instance file table which is organised by double linked list, each entry in the list has a vnode pointer, a reference count.
+2. File Descriptor layer, there is a file descriptor table for each process(struct proc) which manages allocating/deallocating file descriptor and finding open file entry via file descriptor.
+
+********************************************
+*          Design Detail
+********************************************
+
+1. Open File Table layer
+
+a. Data Structure
+    struct files_table ->
+         this is a global singleton open file table instance,
+         whose struct member consists of files_table_lock(spinlock to deal with multi-thread manipulating the files_table),
+         and the list head pointer which organises the attached list entries.
+	struct file ->
+         This is an entry in files_table,
+         which contains link_obj(struct list_head) to be attached to files_table, this is the key point of the intrusive linked list,
+         a referece count which means how many file descriptor refer to this entry,
+         a vnode pointer for file operation,
+         a lock dealing with concurrency issue of file operation,
+         and some other data members such as permission flag, pos.
+
+b. Functions
+    inc_ref_file/close_kern_file ->
+        using atomic reference count, in close_kern_file it decrease the reference count by one, and check the reference count after that equal to 0 or not(this is an atomic operation), if yes, calling vfs_close to free vnode, and remove it from (list)files_table, then free it.
+
+     do_flip_open ->
+         vfs_open file with its path passed by argument, then init file struct with the vnode pointer returned by vfs_open, after that insert it into files_table
+
+     kern_file_seek ->
+         because emufs does not provide seek api, so we should maintain pos in the file struct, what we do in this function is calculate the position by the current position and the arguments given by user. Also lock is needed to deal with race condition of manipulating pos.
+
+     kern_file_write/kern_file_read ->
+         calling VOP_WRITE and VOP_READ to achieve reading and writing, and we also use lock deal with concurrency issues while operating on the same vnode pointer.
+         another thing is updating pos in the two function after operation, if the open_flag contain O_APPEND while writing, it will set the pos at the end of the file, then begin to write.
+
+
+
+
+2. File Descriptor layer
+a. Data Structure
+Every process contains a fdtable, which contains following members,
+    max_fds indicates how many fd the table supports.
+    fd_array is the array of the file pointer to open file table entry.
+    open_fds_bits is a bitmap recording which entries in fd_array is used or not.
+    file_lock is a spinlock to deal with concurrency issue of the fd_array and open_fds_bits
+
+
+
+b. Functions
+   all the do_sys_xxx functions are following almost the same executing flow, they find open file layer pointer in fd array with the fd number, and use file_lock to solve race condition.
+   And we play a trick here, before operating the file pointer, increasing the ref count in order to avoid other threads close the file pointer.
+
+   also provide a function called init_stdio only for kernel process initial, which setup stdin, stdout and stdout file descriptor.
+
+
+
+
+********************************************
+*   Functionalities of new added files
+********************************************
+
+1. kern/include/list.h kern/include/list.c ->
+    copied from linux kernel which implements double linked list,
+    also intrusive link list is added, which is used to managing entry in Open File Table layer.
+
+2. kern/arch/mips/include/atomic.h ->
+    wrapped LL/SC instructions in mips to provide atomic function,
+    using atomic instead of spinlock to deal with concurrency issue while managing reference count of the entry in Open File Table layer.
+
+3. kern/include/fdtable.h ->
+    defination of data structure and exported functions in File Descriptor layer.
+
+4. kern/include/file.h ->
+    defination of data structure and exported functions in Open File Table layer.
+
+5. kern/syscall/file.c ->
+    preparation work before go into File Descriptor layer, such as copying user level buf to kernel buf.
+
+6. kern/syscall/fdtable.c ->
+    main implementation of File Descriptor layer.
+
+7. kern/syscall/kern_file.c ->
+    main implementation of Open File Table layer.
+
+
diff --git kern/arch/mips/include/atomic.h kern/arch/mips/include/atomic.h
new file mode 100644
index 0000000..d208252
--- /dev/null
+++ kern/arch/mips/include/atomic.h
@@ -0,0 +1,455 @@
+/*
+ * Copyright (C) 2006 iptelorg GmbH
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+/**
+ * @file
+ * @brief Atomic operations and memory barriers (MIPS isa 2 and MIPS64 specific)
+ *
+ * Atomic operations and memory barriers (MIPS isa 2 and MIPS64 specific)
+ * warning atomic ops do not include memory barriers, see atomic_ops.h for
+ * more details.
+ * warning not tested on MIPS64 (not even a compile test)
+ *
+ * Config defines:
+ * - NOSMP (in NOSMP mode it will also work on mips isa 1 CPUs that support
+ *   LL and SC, see MIPS_HAS_LLSC in atomic_ops.h)
+ * - __CPU_MIPS64 (mips64 arch., in 64 bit mode: long and void* are 64 bits)
+ * - __CPU_MIPS2 or __CPU_MIPS && MIPS_HAS_LLSC && NOSMP (if __CPU_MIPS64 is not defined)
+ * @ingroup atomic
+ */
+/* atomic api in mips
+ * copied from:
+ * https://github.com/kamailio/kamailio */
+
+// I want to use atomic instead of spinlock, just want to experiment new things...
+// i think this does not valiate https://student.unsw.edu.au/plagiarism
+
+
+#ifndef _atomic_mips2_h
+#define _atomic_mips2_h
+
+/* #define HAVE_ASM_ _ATOMIC_OPS */
+/* #define HAVE_ASM_ _MEMBAR */
+
+#ifdef __CPU_mips64
+#warning mips64 atomic code was not tested, please report problems to \
+        serdev@iptel.org or andrei@iptel.org
+#endif
+
+#ifdef NOSMP
+#define membar() asm volatile ("" : : : "memory") /* gcc do not cache barrier*/
+#define membar_read()  membar()
+#define membar_write() membar()
+#define membar_depends()  do {} while(0) /* really empty, not even a cc bar. */
+/* lock barriers: empty, not needed for NOSMP; the lock/unlock should already
+ * contain gcc barriers*/
+#define membar_enter_lock() do {} while(0)
+#define membar_leave_lock() do {} while(0)
+/* membars after or before atomic_ops or atomic_setget -> use these or
+ *  mb_<atomic_op_name>() if you need a memory barrier in one of these
+ *  situations (on some archs where the atomic operations imply memory
+ *   barriers is better to use atomic_op_x(); membar_atomic_op() then
+ *    atomic_op_x(); membar()) */
+#define membar_atomic_op()              membar()
+#define membar_atomic_setget()          membar()
+#define membar_write_atomic_op()        membar_write()
+#define membar_write_atomic_setget()    membar_write()
+#define membar_read_atomic_op()         membar_read()
+#define membar_read_atomic_setget()     membar_read()
+
+#else
+
+#define membar() \
+    asm volatile( \
+            ".set push \n\t" \
+            ".set noreorder \n\t" \
+            ".set mips2 \n\t" \
+            "    sync\n\t" \
+            ".set pop \n\t" \
+            : : : "memory" \
+            )
+
+#define membar_read()  membar()
+#define membar_write() membar()
+#define membar_depends()  do {} while(0) /* really empty, not even a cc bar. */
+#define membar_enter_lock() membar()
+#define membar_leave_lock() membar()
+/* membars after or before atomic_ops or atomic_setget -> use these or
+ *  mb_<atomic_op_name>() if you need a memory barrier in one of these
+ *  situations (on some archs where the atomic operations imply memory
+ *   barriers is better to use atomic_op_x(); membar_atomic_op() then
+ *    atomic_op_x(); membar()) */
+#define membar_atomic_op()              membar()
+#define membar_atomic_setget()          membar()
+#define membar_write_atomic_op()        membar_write()
+#define membar_write_atomic_setget()    membar_write()
+#define membar_read_atomic_op()         membar_read()
+#define membar_read_atomic_setget()     membar_read()
+
+#endif /* NOSMP */
+
+
+
+/* main asm block */
+#define ATOMIC_ASM_OP_int(op) \
+            ".set push \n\t" \
+            ".set noreorder \n\t" \
+            ".set mips2 \n\t" \
+            "1:   ll %1, %0 \n\t" \
+            "     " op "\n\t" \
+            "     sc %2, %0 \n\t" \
+            "     beqz %2, 1b \n\t" \
+            "     nop \n\t" /* delay slot */ \
+            ".set pop \n\t"
+
+#ifdef __CPU_mips64
+#define ATOMIC_ASM_OP_long(op) \
+            ".set push \n\t" \
+            ".set noreorder \n\t" \
+            "1:   lld %1, %0 \n\t" \
+            "     " op "\n\t" \
+            "     scd %2, %0 \n\t" \
+            "     beqz %2, 1b \n\t" \
+            "     nop \n\t" /* delay slot */ \
+            ".set pop \n\t"
+#else /* ! __CPU_mips64 => __CPU_mips2 or __CPU_mips & MIPS_HAS_LLSC */
+#define ATOMIC_ASM_OP_long(op) ATOMIC_ASM_OP_int(op)
+#endif
+
+
+#define ATOMIC_FUNC_DECL(NAME, OP, P_TYPE, RET_TYPE, RET_EXPR) \
+       static inline RET_TYPE atomic_##NAME##_##P_TYPE (volatile P_TYPE *var) \
+    { \
+        P_TYPE ret, tmp; \
+        asm volatile( \
+            ATOMIC_ASM_OP_##P_TYPE(OP) \
+            : "=m"(*var), "=&r"(ret), "=&r"(tmp)  \
+            : "m"(*var) \
+             \
+            ); \
+        return RET_EXPR; \
+    }
+
+
+/* same as above, but with CT in %3 */
+#define ATOMIC_FUNC_DECL_CT(NAME, OP, CT, P_TYPE, RET_TYPE, RET_EXPR) \
+      static inline  RET_TYPE atomic_##NAME##_##P_TYPE (volatile P_TYPE *var) \
+    { \
+        P_TYPE ret, tmp; \
+        asm volatile( \
+            ATOMIC_ASM_OP_##P_TYPE(OP) \
+            : "=m"(*var), "=&r"(ret), "=&r"(tmp)  \
+            : "r"((CT)), "m"(*var) \
+             \
+            ); \
+        return RET_EXPR; \
+    }
+
+
+/* takes an extra param, i which goes in %3 */
+#define ATOMIC_FUNC_DECL1(NAME, OP, P_TYPE, RET_TYPE, RET_EXPR) \
+       static inline RET_TYPE atomic_##NAME##_##P_TYPE (volatile P_TYPE *var, \
+                                                        P_TYPE i) \
+    { \
+        P_TYPE ret, tmp; \
+        asm volatile( \
+            ATOMIC_ASM_OP_##P_TYPE(OP) \
+            : "=m"(*var), "=&r"(ret), "=&r"(tmp)  \
+            : "r"((i)), "m"(*var) \
+             \
+            ); \
+        return RET_EXPR; \
+    }
+
+
+/* takes an extra param, like above, but i  goes in %2 */
+#define ATOMIC_FUNC_DECL2(NAME, OP, P_TYPE, RET_TYPE, RET_EXPR) \
+       static inline RET_TYPE atomic_##NAME##_##P_TYPE (volatile P_TYPE *var, \
+                                                        P_TYPE i) \
+    { \
+        P_TYPE ret; \
+        asm volatile( \
+            ATOMIC_ASM_OP_##P_TYPE(OP) \
+            : "=m"(*var), "=&r"(ret), "+&r"(i)  \
+            : "m"(*var) \
+             \
+            ); \
+        return RET_EXPR; \
+    }
+
+
+/* %0=var, %1=*var, %2=new, %3=old :
+ * ret=*var; if *var==old  then *var=new; return ret
+ * => if succesfull (changed var to new)  ret==old */
+#define ATOMIC_CMPXCHG_DECL(NAME, P_TYPE) \
+       static inline P_TYPE atomic_##NAME##_##P_TYPE (volatile P_TYPE *var, \
+                                                        P_TYPE old, \
+                                                        P_TYPE new_v) \
+    { \
+        asm volatile( \
+            ATOMIC_ASM_OP_##P_TYPE("bne %1, %3, 2f \n\t nop") \
+            "2:    \n\t" \
+            : "=m"(*var), "=&r"(old), "=r"(new_v)  \
+            : "r"(old), "m"(*var), "2"(new_v) \
+             \
+            ); \
+        return old; \
+    }
+ #define ATOMIC_CMPXCHG_DEC_TO_TARGET(NAME, P_TYPE) \
+        static inline P_TYPE atomic_##NAME##_##P_TYPE (volatile P_TYPE *var, \
+                                                         P_TYPE target)\
+     { \
+         P_TYPE tmp1 = 0, tmp2 = 0; \
+         P_TYPE retval = 0;\
+         asm volatile( \
+                      ATOMIC_ASM_OP_##P_TYPE("move %2, %1 ; beq %1, %4, 2f ; nop;   addi %2, %1, -1; sub %3 , %4, %2\n\t") \
+                      "j 3f; nop\n\t"\
+                      "2:   sub %3, %4, %2  \n\t" \
+                      "3: nop\n\t"\
+                      : "+m"(*var), "=&r"(tmp1), "+&r"(tmp2) , "=&r"(retval) \
+                      : "r"(target)\
+                     ); \
+         return (retval == 0); \
+     }
+/*
+ *asm volatile( \
+             ATOMIC_ASM_OP_##P_TYPE("move %2, %1 ; beq %1, %4, 2f ; nop;   addi %2, %1, -1\n\t") \
+             "2:   sub %3, %4, %2  \n\t" \
+             : "+m"(*var), "=&r"(tmp1), "+r"(tmp2) , "=&r"(retval) \
+             : "r"(target)\
+              \
+             ); \
+
+ */
+
+ATOMIC_CMPXCHG_DEC_TO_TARGET(cmpxchg_dec_to_target, int)
+
+ATOMIC_FUNC_DECL(inc,      "addiu %2, %1, 1", int, void, /* no return */ )
+ATOMIC_FUNC_DECL_CT(dec,   "subu %2, %1, %3", 1,  int, void, /* no return */ )
+ATOMIC_FUNC_DECL1(and, "and %2, %1, %3", int, void, /* no return */ )
+ATOMIC_FUNC_DECL1(or,  "or  %2, %1, %3", int, void,  /* no return */ )
+ATOMIC_FUNC_DECL(inc_and_test, "addiu %2, %1, 1", int, int, (ret+1)==0 )
+ATOMIC_FUNC_DECL_CT(dec_and_test, "subu %2, %1, %3", 1, int, int, (ret-1)==0 )
+ATOMIC_FUNC_DECL2(get_and_set, "" /* nothing needed */, int, int, ret )
+ATOMIC_CMPXCHG_DECL(cmpxchg, int)
+ATOMIC_FUNC_DECL1(add, "addu %2, %1, %3 \n\t move %1, %2", int, int, ret )
+
+#ifdef __CPU_mips64
+
+ATOMIC_FUNC_DECL(inc,      "daddiu %2, %1, 1", long, void, /* no return */ )
+ATOMIC_FUNC_DECL_CT(dec,   "dsubu %2, %1, %3", 1,  long, void, /* no return */ )
+ATOMIC_FUNC_DECL1(and, "and %2, %1, %3", long, void, /* no return */ )
+ATOMIC_FUNC_DECL1(or,  "or  %2, %1, %3", long, void,  /* no return */ )
+ATOMIC_FUNC_DECL(inc_and_test, "daddiu %2, %1, 1", long, long, (ret+1)==0 )
+ATOMIC_FUNC_DECL_CT(dec_and_test, "dsubu %2, %1, %3", 1,long, long, (ret-1)==0 )
+ATOMIC_FUNC_DECL2(get_and_set, "" /* nothing needed */, long, long, ret )
+ATOMIC_CMPXCHG_DECL(cmpxchg, long)
+ATOMIC_FUNC_DECL1(add, "daddu %2, %1, %3 \n\t move %1, %2", long, long, ret )
+
+#else /* ! __CPU_mips64 => __CPU_mips2 or __CPU_mips */
+
+ATOMIC_FUNC_DECL(inc,      "addiu %2, %1, 1", long, void, /* no return */ )
+ATOMIC_FUNC_DECL_CT(dec,   "subu %2, %1, %3", 1,  long, void, /* no return */ )
+ATOMIC_FUNC_DECL1(and, "and %2, %1, %3", long, void, /* no return */ )
+ATOMIC_FUNC_DECL1(or,  "or  %2, %1, %3", long, void,  /* no return */ )
+ATOMIC_FUNC_DECL(inc_and_test, "addiu %2, %1, 1", long, long, (ret+1)==0 )
+ATOMIC_FUNC_DECL_CT(dec_and_test, "subu %2, %1, %3", 1,long, long, (ret-1)==0 )
+ATOMIC_FUNC_DECL2(get_and_set, "" /* nothing needed */, long, long, ret )
+ATOMIC_CMPXCHG_DECL(cmpxchg, long)
+ATOMIC_FUNC_DECL1(add, "addu %2, %1, %3 \n\t move %1, %2", long, long, ret )
+
+#endif /* __CPU_mips64 */
+
+#define atomic_inc(var) atomic_inc_int(&(var)->val)
+#define atomic_dec(var) atomic_dec_int(&(var)->val)
+#define atomic_and(var, mask) atomic_and_int(&(var)->val, (mask))
+#define atomic_or(var, mask)  atomic_or_int(&(var)->val, (mask))
+#define atomic_dec_and_test(var) atomic_dec_and_test_int(&(var)->val)
+#define atomic_inc_and_test(var) atomic_inc_and_test_int(&(var)->val)
+#define atomic_get_and_set(var, i) atomic_get_and_set_int(&(var)->val, i)
+#define atomic_add(var, i) atomic_add_int(&(var)->val, i)
+#define atomic_cmpxchg(var, old, new_v)  \
+    atomic_cmpxchg_int(&(var)->val, old, new_v)
+
+
+/* with integrated membar */
+
+#define mb_atomic_set_int(v, i) \
+    do{ \
+        membar(); \
+        atomic_set_int(v, i); \
+    }while(0)
+
+
+
+
+inline static int mb_atomic_get_int(volatile int* v)
+{
+    membar();
+    return *v;
+    // return atomic_get_int(v);
+}
+
+
+#define mb_atomic_inc_int(v) \
+    do{ \
+        membar(); \
+        atomic_inc_int(v); \
+    }while(0)
+
+#define mb_atomic_dec_int(v) \
+    do{ \
+        membar(); \
+        atomic_dec_int(v); \
+    }while(0)
+
+#define mb_atomic_or_int(v, m) \
+    do{ \
+        membar(); \
+        atomic_or_int(v, m); \
+    }while(0)
+
+#define mb_atomic_and_int(v, m) \
+    do{ \
+        membar(); \
+        atomic_and_int(v, m); \
+    }while(0)
+
+   static inline int mb_atomic_inc_and_test_int(volatile int* v)
+{
+    membar();
+    return atomic_inc_and_test_int(v);
+}
+
+   static inline int mb_atomic_dec_and_test_int(volatile int* v)
+{
+    membar();
+    return atomic_dec_and_test_int(v);
+}
+
+
+   static inline int mb_atomic_get_and_set_int(volatile int* v, int i)
+{
+    membar();
+    return atomic_get_and_set_int(v, i);
+}
+
+   static inline int mb_atomic_cmpxchg_int(volatile int* v, int o, int n)
+{
+    membar();
+    return atomic_cmpxchg_int(v, o, n);
+}
+static inline int mb_atomic_cmpxchg_dec_to_target(volatile int* v, int t )
+{
+    membar();
+    return atomic_cmpxchg_dec_to_target_int(v, t);
+}
+
+
+static inline    int mb_atomic_add_int(volatile int* v, int i)
+{
+    membar();
+    return atomic_add_int(v, i);
+}
+
+
+#define mb_atomic_set_long(v, i) \
+    do{ \
+        membar(); \
+        atomic_set_long(v, i); \
+    }while(0)
+
+
+
+//    long mb_atomic_get_long(volatile long* v)
+// {
+//     membar();
+//     return atomic_get_long(v);
+// }
+
+
+#define mb_atomic_inc_long(v) \
+    do{ \
+        membar(); \
+        atomic_inc_long(v); \
+    }while(0)
+
+
+#define mb_atomic_dec_long(v) \
+    do{ \
+        membar(); \
+        atomic_dec_long(v); \
+    }while(0)
+
+#define mb_atomic_or_long(v, m) \
+    do{ \
+        membar(); \
+        atomic_or_long(v, m); \
+    }while(0)
+
+#define mb_atomic_and_long(v, m) \
+    do{ \
+        membar(); \
+        atomic_and_long(v, m); \
+    }while(0)
+
+static inline   long mb_atomic_inc_and_test_long(volatile long* v)
+{
+    membar();
+    return atomic_inc_and_test_long(v);
+}
+
+   static inline long mb_atomic_dec_and_test_long(volatile long* v)
+{
+    membar();
+    return atomic_dec_and_test_long(v);
+}
+
+
+   static inline long mb_atomic_get_and_set_long(volatile long* v, long l)
+{
+    membar();
+    return atomic_get_and_set_long(v, l);
+}
+
+   static inline long mb_atomic_cmpxchg_long(volatile long* v, long o, long n)
+{
+    membar();
+    return atomic_cmpxchg_long(v, o, n);
+}
+
+   static inline long mb_atomic_add_long(volatile long* v, long i)
+{
+    membar();
+    return atomic_add_long(v, i);
+}
+
+
+#define mb_atomic_inc(var) mb_atomic_inc_int(&(var)->val)
+#define mb_atomic_dec(var) mb_atomic_dec_int(&(var)->val)
+#define mb_atomic_and(var, mask) mb_atomic_and_int(&(var)->val, (mask))
+#define mb_atomic_or(var, mask)  mb_atomic_or_int(&(var)->val, (mask))
+#define mb_atomic_dec_and_test(var) mb_atomic_dec_and_test_int(&(var)->val)
+#define mb_atomic_inc_and_test(var) mb_atomic_inc_and_test_int(&(var)->val)
+#define mb_atomic_get(var)  mb_atomic_get_int(&(var)->val)
+#define mb_atomic_set(var, i)   mb_atomic_set_int(&(var)->val, i)
+#define mb_atomic_get_and_set(var, i) mb_atomic_get_and_set_int(&(var)->val, i)
+#define mb_atomic_cmpxchg(var, o, n) mb_atomic_cmpxchg_int(&(var)->val, o, n)
+#define mb_atomic_add(var, i) mb_atomic_add_int(&(var)->val, i)
+
+#endif
+
+
diff --git kern/arch/mips/syscall/syscall.c kern/arch/mips/syscall/syscall.c
index d37d239..4fcc9fa 100644
--- kern/arch/mips/syscall/syscall.c
+++ kern/arch/mips/syscall/syscall.c
@@ -35,6 +35,11 @@
 #include <thread.h>
 #include <current.h>
 #include <syscall.h>
+#include "endian.h"
+#include "copyinout.h"
+#include "uio.h"
+#include <kern/wait.h>
+#include <kern/machine/endian.h>
 
 
 /*
@@ -75,6 +80,42 @@
  * stack, starting at sp+16 to skip over the slots for the
  * registerized values, with copyin().
  */
+
+static long long concrete_int_2_ll(int high, int low)
+{
+    char tmp[10];
+#if _BYTE_ORDER == _BIG_ENDIAN
+    memcpy(tmp, &high, sizeof(int));
+    memcpy(tmp + 4, &low, sizeof(int));
+#else
+    memcpy(tmp, &low, sizeof(int));
+    memcpy(tmp + 4, &high, sizeof(int));
+
+#endif
+    return *((long long *)(tmp));
+}
+static void split_ll_2_int(int* high, int* low, long long ll)
+{
+    size_t p = (size_t)(&ll) + 0;
+    size_t p1 = (size_t) (& ll) + 4;
+#if _BYTE_ORDER == _BIG_ENDIAN
+
+    memcpy((void*)low, (void*)p, 4);
+    memcpy((void*)high, (void *)p1, 4);
+#else
+    memcpy((void*)low, (void*)p1, 4);
+    memcpy((void*)high, (void *)p, 4);
+#endif
+    return;
+}
+/*
+ * copy [sp+16 + offset,sp+16+len) to dst memory
+ */
+static int fetch_data_from_userstack(struct trapframe * tp, int offset, void* dst, int len)
+{
+    return copyin((const_userptr_t)(tp->tf_sp + 16 + offset ), dst, len);
+}
+
 void
 syscall(struct trapframe *tf)
 {
@@ -98,6 +139,9 @@ syscall(struct trapframe *tf)
 	 */
 
 	retval = 0;
+    int param3;
+    char retval_ll[8] ;
+    bool return_val_is64 = 0;
 
 	switch (callno) {
 	    case SYS_reboot:
@@ -109,11 +153,42 @@ syscall(struct trapframe *tf)
 				 (userptr_t)tf->tf_a1);
 		break;
 
-	    /* Add stuff here */
+
+        /* basic asst2 syscall */
+
+        case SYS_open:
+        err = syscall_open((const_userptr_t)tf->tf_a0, tf->tf_a1, tf->tf_a2, &retval);
+        break;
+        case SYS_read:
+        err = syscall_read(tf->tf_a0, (userptr_t)tf->tf_a1, tf->tf_a2, (size_t *)(&retval));
+        break;
+        case SYS_write:
+        err = syscall_write(tf->tf_a0, ( const_userptr_t )tf->tf_a1, tf->tf_a2, (size_t *)(&retval));
+        break;
+        case SYS_close:
+        err = syscall_close(tf->tf_a0, &retval);
+        break;
+
+        case SYS_lseek:
+        err = fetch_data_from_userstack(tf, 0, &param3, 4);
+        if (err != 0)
+        {
+            break;
+        }
+        err = syscall_lseek(tf->tf_a0, concrete_int_2_ll(tf->tf_a2, tf->tf_a3),param3,  (off_t*)(&retval_ll));
+        return_val_is64 = 1;
+
+        break;
+        case SYS_dup2:
+        err = syscall_dup2(tf->tf_a0, tf->tf_a1, &retval);
+        break;
+
+        /* end */
 
 	    default:
 		kprintf("Unknown syscall %d\n", callno);
 		err = ENOSYS;
+        retval = ENOSYS;
 		break;
 	}
 
@@ -124,14 +199,33 @@ syscall(struct trapframe *tf)
 		 * userlevel to a return value of -1 and the error
 		 * code in errno.
 		 */
-		tf->tf_v0 = err;
+		tf->tf_v0 =  retval < 0 ? - retval: retval;
+        if (return_val_is64)
+        {
+
+            split_ll_2_int((int *)(&tf->tf_v0), (int *)(&tf->tf_v1), *((long long *)(retval_ll)));
+        }
 		tf->tf_a3 = 1;      /* signal an error */
 	}
 	else {
-		/* Success. */
-		tf->tf_v0 = retval;
-		tf->tf_a3 = 0;      /* signal no error */
-	}
+        /*
+         * return val is 64 bit
+         */
+        if (return_val_is64 == 1)
+        {
+            split_ll_2_int((int *)(&tf->tf_v1), (int *)(&tf->tf_v0), *((long long *)(retval_ll)));
+            tf->tf_a3 = 0;
+        }
+        else
+        {
+            /* Success. */
+            /* tf->tf_v1 = */
+            tf->tf_v0 = retval;
+            tf->tf_a3 = 0;      /* signal no error */
+
+
+        }
+    }
 
 	/*
 	 * Now, advance the program counter, to avoid restarting
diff --git kern/build_kern.sh kern/build_kern.sh
new file mode 100755
index 0000000..ea88ad4
--- /dev/null
+++ kern/build_kern.sh
@@ -0,0 +1,26 @@
+#!/bin/bash
+
+# Sets KERN_PATH to the corresponding path
+if [ $# -eq 0 ]; then
+    KERN_PATH=~/cs3231/asst2-src/kern
+# If path is not supplied include --ostree=path/to/root
+else
+    KERN_PATH=$1
+fi
+
+current_path=`pwd`
+cd $KERN_PATH/conf
+echo "In directory: $KERN_PATH/conf"
+echo "----------- Configuring Kernal NOW -----------"
+./config ASST2
+
+cd ../compile/ASST2
+echo "In directory: $KERN_PATH/compile/ASST2"
+echo "----------- Making Kernal NOW  -----------"
+bmake depend
+bmake
+bmake install
+echo "----------- Finished Making Kernel -----------"
+
+cd $current_path
+
diff --git kern/conf/conf.kern kern/conf/conf.kern
index 6d3194c..f29e4b6 100644
--- kern/conf/conf.kern
+++ kern/conf/conf.kern
@@ -283,6 +283,7 @@ file      lib/kprintf.c
 file      lib/misc.c
 file      lib/time.c
 file      lib/uio.c
+file      lib/list.c
 
 defoption noasserts
 
@@ -380,6 +381,8 @@ file      syscall/loadelf.c
 file      syscall/runprogram.c
 file      syscall/time_syscalls.c
 file	  syscall/file.c
+file	  syscall/kern_file.c
+file	  syscall/fdtable.c
 #
 # Startup and initialization
 #
@@ -438,6 +441,7 @@ file		test/threadtest.c
 file		test/tt3.c
 file		test/synchtest.c
 file		test/semunit.c
+file		test/file_multithreadtest.c
 file		test/kmalloctest.c
 file		test/fstest.c
 optfile net	test/nettest.c
diff --git kern/include/debug_print.h kern/include/debug_print.h
new file mode 100644
index 0000000..521c831
--- /dev/null
+++ kern/include/debug_print.h
@@ -0,0 +1,43 @@
+#ifndef _DEBUG_PRINT_H_
+#define _DEBUG_PRINT_H_
+#include <lib.h>
+#include <cdefs.h>
+#define NONE                 "\e[0m"
+
+#define BLACK                "\e[0;30m"
+#define L_BLACK              "\e[1;30m"
+#define RED                  "\e[0;31m"
+#define L_RED                "\e[1;31m"
+#define GREEN                "\e[0;32m"
+#define L_GREEN              "\e[1;32m"
+#define BROWN                "\e[0;33m"
+#define YELLOW               "\e[1;33m"
+#define BLUE                 "\e[0;34m"
+#define L_BLUE               "\e[1;34m"
+#define PURPLE               "\e[0;35m"
+#define L_PURPLE             "\e[1;35m"
+#define CYAN                 "\e[0;36m"                                                          #define L_CYAN               "\e[1;36m"
+#define GRAY                 "\e[0;37m"
+#define WHITE                "\e[1;37m"
+
+#define BOLD                 "\e[1m"
+#define UNDERLINE            "\e[4m"
+#define BLINK                "\e[5m"
+#define REVERSE              "\e[7m"
+#define HIDE                 "\e[8m"
+#define CLEAR                "\e[2J"
+#define CLRLINE              "\r\e[K" //or "\e[1K\r"
+
+#define OPEN_DEBUG_PRINT 0
+
+#ifdef OPEN_DEBUG_PRINT
+// #define DEBUG_PRINT (fmt, ...)  kprintf("[%s:%d]-<%s>: "##fmt, __FILE__, __LINE__, __FUNCTION__, ##__VA_ARGS__)
+#define DEBUG_PRINT ( kprintf)
+// #define DEBUG_PRINT (kprintf(BLUE "<%s>-[%s:%d] " NONE, __FUNCTION__,__FILE__, __LINE__), kprintf)
+// #define DEBUG_PRINT (fmt, ...) (kprintf(BLUE "<%s>-[%s:%d] ", __FUNCTION__,__FILE__, __LINE__), kprintf(__VA_ARGS__, NONE))
+// #define DEBUG_PRINT(fmt, ...) kprintf(__VA_ARGS__)
+#else
+#define DEBUG_PRINT (fmt, ...) void(0)
+#endif
+
+#endif
diff --git kern/include/fdtable.h kern/include/fdtable.h
new file mode 100644
index 0000000..94ccada
--- /dev/null
+++ kern/include/fdtable.h
@@ -0,0 +1,50 @@
+#ifndef _FD_TABLE_H_
+#define _FD_TABLE_H_
+
+#include <spinlock.h>
+#include <synch.h>
+#include <stat.h>
+#include <list.h>
+
+
+struct file;
+#define MAX_FD_COUNT_PER_PROCESS 128
+#define FD_BITS (sizeof(unsigned int) * 8)
+
+struct fdtable
+{
+    unsigned int max_fds;
+    struct file **fd_array;
+    // unsigned int *full_fds_bits;
+    volatile unsigned int *open_fds_bits;
+
+};
+
+struct files_struct
+{
+    struct fdtable* fdt;
+    struct spinlock file_lock;
+    // unsigned int next_fd;
+
+};
+
+static inline bool
+is_valid_fd(struct files_struct*f, int fd)
+{
+    return !(fd < 0 || fd >= (int)f->fdt->max_fds);
+}
+
+int do_sys_open(int dfd, void * filename, int flags, mode_t mode, struct files_struct*);
+int do_sys_close(int fd);
+int do_sys_dup2(int oldfd, int newfd) ;
+off_t do_sys_lseek(int fd, off_t pos, int whence);
+
+ssize_t do_sys_read(int fd, char* buf, size_t buf_len);
+
+ssize_t do_sys_write(int fd, const void *buf, size_t nbytes);
+
+
+int init_fd_table(struct proc* cur);
+void destroy_fd_table(struct proc* proc);
+int init_stdio(struct files_struct* fst);
+#endif
diff --git kern/include/file.h kern/include/file.h
index a9939e3..4ce7548 100644
--- kern/include/file.h
+++ kern/include/file.h
@@ -1,20 +1,61 @@
-/*
- * Declarations for file handle and file table management.
- */
-
 #ifndef _FILE_H_
 #define _FILE_H_
 
-/*
- * Contains some file-related maximum length constants
- */
-#include <limits.h>
+#include <spinlock.h>
+#include <synch.h>
+#include <stat.h>
+#include <list.h>
+#include "vnode.h"
 
 
+struct vnode;
+struct fs;
+
 /*
- * Put your function declarations and data types here ...
+ * kernel file, which is pointed by file descripter
+ * linked in intrusive list
+ *
  */
 
+struct files_table;
+struct file
+{
+    struct list_head link_obj; /* link unit of intrusive list*/
+
+    volatile int ref_count;
+    // struct spinlock f_lock;
+
+    struct vnode* v_ptr;
+
+    int f_flags;
+    off_t f_pos; // the current seek position of the file
+    struct lock*  file_op_lock;
+    struct stat f_stat;
+
+    struct files_table* owner;
+
+
+};
+
+struct files_table
+{
+    struct spinlock files_table_lock;
+    // struct lock*
+    struct list* list_obj;
+
+};
+
+void inc_ref_file(struct file* f)  ;
+int close_kern_file(struct file* fs, struct spinlock* fs_lock);
+int do_flip_open(struct file ** fp, int dfd, char* filename, int flags, mode_t mode);
+off_t kern_file_seek(struct file* f,  off_t pos, int whence);
+ssize_t kern_file_read(struct file* f, char* buf, size_t buf_size, size_t* read_len);
+
+int kern_file_write(struct file* f, const void * buf, size_t buf_size, size_t * read_len);
+
+
+void init_kern_file_table(void);
+void destroy_kern_file_table(void);
 
 
-#endif /* _FILE_H_ */
+#endif
diff --git kern/include/kern/types.h kern/include/kern/types.h
index 002d3b7..e4923da 100644
--- kern/include/kern/types.h
+++ kern/include/kern/types.h
@@ -83,6 +83,8 @@ typedef __i32 __uid_t;     /* User ID */
 typedef int __nfds_t;    /* Number of file handles */
 typedef int __socklen_t;   /* Socket-related length */
 
+typedef int __atomic_t;  /* used in atomic.h */
+
 /* See note in <stdarg.h> */
 #ifdef __GNUC__
 typedef __builtin_va_list __va_list;
diff --git kern/include/list.h kern/include/list.h
new file mode 100644
index 0000000..39899b8
--- /dev/null
+++ kern/include/list.h
@@ -0,0 +1,386 @@
+/*
+    copied from linux kernel, doubly linked list
+
+    modified for intrusive list, which used in kernel global open file table
+
+    Copyright (C) Shenglong Chen
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+
+Shenglong Chen
+email: chenshenglong1990@gmail.com
+
+*/
+
+#ifndef _LIST_H_
+#define _LIST_H_
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#define __builtin_prefetch(x,y,z) (void)1
+
+
+/*
+linked meta structure
+*/
+struct list_head {
+    struct list_head *next, *prev;
+    struct list* owner; // the list belong to
+};
+
+/*
+the link head of the list
+*/
+struct list {
+    struct list_head head;
+    int offset; /* used to locate the list_head in linked struct, should be init before calling any other functions */
+
+};
+
+
+#if 0
+#define LIST_HEAD_INIT(name) { &(name), &(name) }
+#define LIST_HEAD(name) \
+    struct list_head name = LIST_HEAD_INIT(name)
+#endif
+
+#define INIT_LIST_HEAD(ptr) do { \
+    (ptr)->next = (ptr); (ptr)->prev = (ptr); \
+} while (0)
+
+/*
+ * Insert a p entry between two known consecutive entries.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_add(struct list_head *p,
+                              struct list_head *prev,
+                              struct list_head *next)
+{
+    next->prev = p;
+    p->next = next;
+    p->prev = prev;
+    prev->next = p;
+}
+
+/**
+ * list_add - add a p entry
+ * @p: p entry to be added
+ * @head: list head to add it after
+ *
+ * Insert a p entry after the specified head.
+ * This is good for implementing stacks.
+ */
+static inline void list_add(struct list_head *p, struct list_head *head)
+{
+    __list_add(p, head, head->next);
+}
+/**
+ * list_add_tail - add a p entry
+ * @p: p entry to be added
+ * @head: list head to add it before
+ *
+ * Insert a p entry before the specified head.
+ * This is useful for implementing queues.
+ */
+static inline void list_add_tail(struct list_head *p, struct list_head *head)
+{
+    __list_add(p, head->prev, head);
+}
+
+/*
+ * Delete a list entry by making the prev/next entries
+ * point to each other.
+ *
+ * This is only for internal list manipulation where we know
+ * the prev/next entries already!
+ */
+static inline void __list_del(struct list_head *prev, struct list_head *next)
+{
+    next->prev = prev;
+    prev->next = next;
+}
+// void __list_del(struct list_head *prev, struct list_head *next);
+
+/**
+ * list_del - deletes entry from list.
+ * @entry: the element to delete from the list.
+ * Note: list_empty on entry does not return true after this, the entry is in an undefined state.
+ */
+void list_del(struct list_head *link);
+
+/**
+ * list_del_init - deletes entry from list and reinitialize it.
+ * @entry: the element to delete from the list.
+ */
+static inline void list_del_init(struct list_head *entry)
+{
+    __list_del(entry->prev, entry->next);
+    INIT_LIST_HEAD(entry);
+}
+
+/**
+ * list_move - delete from one list and add as another's head
+ * @list: the entry to move
+ * @head: the head that will precede our entry
+ */
+static inline void list_move(struct list_head *list, struct list_head *head)
+{
+    __list_del(list->prev, list->next);
+    list_add(list, head);
+}
+/**
+ * list_move_tail - delete from one list and add as another's tail
+ * @list: the entry to move
+ * @head: the head that will follow our entry
+ */
+static inline void list_move_tail(struct list_head *list,
+                                  struct list_head *head)
+{
+    __list_del(list->prev, list->next);
+    list_add_tail(list, head);
+}
+
+/**
+ * list_empty - tests whether a list is empty
+ * @head: the list to test.
+ */
+static inline int list_empty(const struct list_head *head)
+{
+    return head->next == head;
+}
+
+static inline void __list_splice(struct list_head *list,
+                                 struct list_head *head)
+{
+    struct list_head *first = list->next;
+    struct list_head *last = list->prev;
+    struct list_head *at = head->next;
+
+    first->prev = head;
+    head->next = first;
+
+    last->next = at;
+    at->prev = last;
+}
+
+/**
+ * list_splice - join two lists
+ * @list: the p list to add.
+ * @head: the place to add it in the first list.
+ */
+static inline void list_splice(struct list_head *list, struct list_head *head)
+{
+    if (!list_empty(list))
+        __list_splice(list, head);
+}
+
+/**
+ * list_splice_init - join two lists and reinitialise the emptied list.
+ * @list: the p list to add.
+ * @head: the place to add it in the first list.
+ *
+ * The list at @list is reinitialised
+ */
+static inline void list_splice_init(struct list_head *list,
+                                    struct list_head *head)
+{
+    if (!list_empty(list)) {
+        __list_splice(list, head);
+        INIT_LIST_HEAD(list);
+    }
+}
+
+#ifndef offsetof
+#define offsetof(type, member) (unsigned long)(&((type *)0)->member)
+#endif
+
+
+
+/**
+ * list_entry - get the struct for this entry
+ * @ptr:    the &struct list_head pointer.
+ * @type:   the type of the struct this is embedded in.
+ * @member: the name of the list_struct within the struct.
+ */
+#define list_entry(ptr, type, member) \
+    ((type *)((char *)(ptr)-offsetof(type, member)))
+/*
+// container_of is same as list_entry
+// #ifndef container_of
+// #define container_of(ptr, type, member) ({ \
+//         const typeof( ((type *)0)->member ) *__mptr = (ptr); \
+//         (type *)( (char *)__mptr - offsetof(type,member) );})
+// #endif
+*/
+
+/**
+ * list_for_each    -   iterate over a list
+ * @pos:    the &struct list_head to use as a loop counter.
+ * @head:   the head for your list.
+ */
+#define list_for_each(pos, head) \
+    for (pos = (head)->next, __builtin_prefetch(pos->next,0,1); \
+     pos != (head); \
+     pos = pos->next, __builtin_prefetch(pos->next,0,1)) \
+
+#define __list_for_each(pos, head) \
+    for (pos = (head)->next; pos != (head); pos = pos->next)
+/**
+ * list_for_each_prev   -   iterate over a list backwards
+ * @pos:    the &struct list_head to use as a loop counter.
+ * @head:   the head for your list.
+ */
+#define list_for_each_prev(pos, head) \
+    for (pos = (head)->prev, __builtin_prefetch(pos->prev,0,1); \
+     pos != (head); \
+     pos = pos->prev, __builtin_prefetch(pos->prev,0,1))
+
+#define __list_for_each_prev(pos, head) \
+    for (pos = (head)->prev; pos != (head); \
+            pos = pos->prev)
+
+/**
+ * list_for_each_safe   -   iterate over a list safe against removal of list entry
+ * @pos:    the &struct list_head to use as a loop counter.
+ * @n:      another &struct list_head to use as temporary storage
+ * @head:   the head for your list.
+ */
+#define list_for_each_safe(pos, n, head) \
+    for (pos = (head)->next, n = pos->next; pos != (head); \
+        pos = n, n = pos->next)
+
+/**
+ * list_for_each_entry  -   iterate over list of given type
+ * @pos:    the type * to use as a loop counter.
+ * @head:   the head for your list.
+ * @member: the name of the list_struct within the struct.
+ */
+#define list_for_each_entry(pos, head, member)              \
+    for (pos = list_entry((head)->next, typeof(*pos), member),  \
+         __builtin_prefetch(pos->member.next,0,1);          \
+         &pos->member != (head);                    \
+         pos = list_entry(pos->member.next, typeof(*pos), member),  \
+         __builtin_prefetch(pos->member.next,0,1))
+
+
+/**
+ * link_next_entry - get the next entry which contains the list head
+ *
+ * @cur:       current entry.
+ * @type:      the type of the struct this is embedded in.
+ * @member:    the name of the list_struct within the struct.
+ *
+ * @return:
+ */
+#define link_next_entry(cur, type, member)  ({\
+        cur->member.next == &(cur->member.owner->head) ? NULL:list_entry(cur->member.next, type, member);\
+    })
+
+// more stupid way than entry->member.
+static inline struct list_head* list_get_link_from_entry(struct list *l, void *entry)
+{
+      return (struct list_head*) ((size_t) entry + l->offset);
+}
+
+// same as list_entry
+static inline void* list_get_entry_from_link(struct list_head* link)
+{
+    if (link == NULL)
+    {
+        return NULL;
+    }
+
+    return (void*) ((size_t) link - link->owner->offset);
+}
+
+
+
+/**
+ * list_for_each_entry  -   iterate over list of given type, can safely detach the entry
+ *                          from list within the loop.
+ * @pos:    the pointer of struct list_head* to use as a loop counter.
+ * @n:      tm pointer of struct list_head*
+ * @l:      the list pointer
+ */
+#define list_for_each_entry_safe(pos, n, l)\
+     for ( pos = ((l)->head.next == &((l)->head) ? NULL:list_get_entry_from_link((l)->head.next)), \
+                  (n) = (pos == NULL?n: *list_get_link_from_entry(l, pos)); \
+          pos != NULL;\
+          pos = ((n).next == &((l)->head)?NULL:list_get_entry_from_link(n.next)),  \
+                  (n) = (pos == NULL?n: *list_get_link_from_entry(l, pos)))
+
+
+
+/**
+ * link_detach
+ *
+ * @cur:    the entry need to be detached.
+ * @member: the name of the list_struct within the struct.
+ *
+ */
+#define link_detach(cur, member) do{\
+    list_del(&((cur)->member));\
+    (cur)->member.owner = NULL;\
+} while(0);
+
+struct list* init_list(size_t offset);
+void destroy_list(struct list* );
+bool is_list_empty(const struct list* );
+void make_list_empty(struct list *); /*  the caller should destroy all the linked entry, this function is simply detach all the entrys*/
+
+void list_insert_head(struct list *l, void* entry);
+void list_insert_tail(struct list *l, void* entry);
+void* list_head(struct list* l);
+// void* list_tail(struct list* l);
+
+
+
+/*
+ * operations for linked entry
+ */
+void link_init(struct list_head* );
+struct list_head* link_next(struct list_head*);
+bool is_linked(struct list_head* );
+
+
+
+// void link_detach1(void* entry, struct list* l); //  list * l is only for get the struct list* in void* entry
+// void link_detach2(void* entry, int offset); //  lis
+
+
+
+
+
+
+
+
+#endif
+
+
+// struct  list my_list;
+// int main()
+// {
+//     INIT_LIST_HEAD(&(my_list.head));
+//     my_list.offset = offsetof(struct entry , object);
+//
+    /* struct entry* p, v; */
+    /* attach(&my_list, v); */
+    /* dettach(&my_list, v); */
+    /* void* s = p + 1; */
+    /* size_t ss = (size_t) p + 1; */
+//     return 0;
+// }
diff --git kern/include/proc.h kern/include/proc.h
index f63c48c..c4fe623 100644
--- kern/include/proc.h
+++ kern/include/proc.h
@@ -37,10 +37,13 @@
  */
 
 #include <spinlock.h>
+#include <bitmap.h>
+#include <list.h>
 
 struct addrspace;
 struct thread;
 struct vnode;
+struct process_fd_table;
 
 /*
  * Process structure.
@@ -70,6 +73,11 @@ struct proc {
 	/* VFS */
 	struct vnode *p_cwd;		/* current working directory */
 
+    struct files_struct* fs_struct;
+
+
+
+
 	/* add more material here as needed */
 };
 
@@ -79,6 +87,8 @@ extern struct proc *kproc;
 /* Call once during system startup to allocate data structures. */
 void proc_bootstrap(void);
 
+
+
 /* Create a fresh process for use by runprogram(). */
 struct proc *proc_create_runprogram(const char *name);
 
@@ -97,5 +107,6 @@ struct addrspace *proc_getas(void);
 /* Change the address space of the current process, and return the old one. */
 struct addrspace *proc_setas(struct addrspace *);
 
+struct proc* get_current_proc(void);
 
 #endif /* _PROC_H_ */
diff --git kern/include/syscall.h kern/include/syscall.h
index ad59b0f..0ce1ec6 100644
--- kern/include/syscall.h
+++ kern/include/syscall.h
@@ -59,4 +59,13 @@ __DEAD void enter_new_process(int argc, userptr_t argv, userptr_t env,
 int sys_reboot(int code);
 int sys___time(userptr_t user_seconds, userptr_t user_nanoseconds);
 
+/* asst2 file system interface */
+int syscall_open(const_userptr_t filename, int flags, mode_t mode, int* fd_num);
+int syscall_close(int fd_num, int *retval);
+int syscall_dup2(int oldfd, int newfd, int* retval);
+int syscall_lseek(int fd, off_t pos, int whence, off_t* retval) ;
+int syscall_write(int fd, const_userptr_t buf, size_t nbytes, size_t* retval)   ;
+int syscall_read(int fd, userptr_t buf, size_t buflen, size_t * retval) ;
+
+
 #endif /* _SYSCALL_H_ */
diff --git kern/include/test.h kern/include/test.h
index 7b02114..a6eb544 100644
--- kern/include/test.h
+++ kern/include/test.h
@@ -94,6 +94,7 @@ int kmallocstress(int, char **);
 int kmalloctest3(int, char **);
 int kmalloctest4(int, char **);
 int nettest(int, char **);
+int file_multithread_test(int, char **);
 
 /* Routine for running a user-level program. */
 int runprogram(char *progname);
diff --git kern/include/types.h kern/include/types.h
index ef310e0..a0cd0b6 100644
--- kern/include/types.h
+++ kern/include/types.h
@@ -133,6 +133,7 @@ typedef __uid_t uid_t;
 typedef __nfds_t nfds_t;
 typedef __socklen_t socklen_t;
 
+typedef __atomic_t atomic_t;
 /*
  * Number of bits per byte.
  */
diff --git kern/lib/list.c kern/lib/list.c
new file mode 100644
index 0000000..eb76d51
--- /dev/null
+++ kern/lib/list.c
@@ -0,0 +1,117 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <vm.h>
+#include "list.h"
+
+struct list* init_list(size_t offset)
+{
+    struct list* l = kmalloc(sizeof(struct list));
+    if (l == NULL)
+    {
+        return NULL;
+    }
+    l->offset = offset;
+    link_init(&(l->head));
+    return l;
+}
+
+bool is_list_empty(const struct list* l)
+{
+    KASSERT(l != NULL);
+    return list_empty(&(l->head));
+}
+void destroy_list(struct list* l)
+{
+    KASSERT(is_list_empty(l));
+    kfree(l);
+    return;
+}
+void make_list_empty(struct list * l)
+{
+    struct list_head* pos = NULL;
+    struct list_head* tmp = NULL;
+    list_for_each_safe(pos, tmp, &(l->head))
+    {
+        if (pos == NULL)
+        {
+            break;
+        }
+        list_del(pos);
+        pos->owner = NULL;
+    }
+    return;
+}
+ void list_insert_head(struct list* l, void* entry)
+ {
+     struct     list_head* tmp = list_get_link_from_entry(l, entry);
+     list_add(tmp, &(l->head));
+     tmp->owner = l;
+     return;
+ }
+void list_insert_tail(struct list *l, void* entry)
+{
+    struct list_head* tmp = list_get_link_from_entry(l, entry);
+    list_add_tail(tmp,  &(l->head));
+    tmp->owner = l;
+    return;
+
+
+}
+void* list_head(struct list* l)
+{
+    struct list_head * tmp = link_next(&l->head);
+    return (void * )((size_t)tmp - l->offset);
+
+}
+struct list_head* link_next(struct list_head* link)
+{
+    KASSERT(link != NULL);
+    return link->next;
+}
+
+
+/* void* link_prev(struct list_head* link) */
+/* { */
+/*  */
+/* } */
+
+/* void link_detach1(void* entry, struct list* l) */
+/* { */
+/*      struct     list_head* tmp = list_get_link_from_entry(l, entry); */
+/*      list_del(tmp); */
+/*      tmp->owner = NULL; */
+/*      return; */
+/* } */
+
+/* void link_detach2(void* entry, int offset) */
+/* { */
+/*     struct list_head* tmp = (struct list_head*) ((size_t) entry + offset); */
+/*     list_del(tmp); */
+/*      tmp->owner = NULL; */
+/*     return; */
+/* } */
+
+void link_init(struct list_head* link)
+{
+    link->owner = NULL ;
+    INIT_LIST_HEAD(link);
+    return;
+}
+bool is_linked(struct list_head* link)
+{
+    return !(link->next == link->prev && (link->next == link ||link->next == NULL) && link->owner == NULL);
+
+}
+/* void __list_del(struct list_head *prev, struct list_head *next) */
+/* { */
+/*     next->prev = prev; */
+/*     prev->next = next; */
+/* } */
+void list_del(struct list_head *entry)
+{
+    __list_del(entry->prev, entry->next);
+    entry->next = 0;
+    entry->prev = 0;
+}
diff --git kern/main/main.c kern/main/main.c
index 9ef7189..f8be1ee 100644
--- kern/main/main.c
+++ kern/main/main.c
@@ -49,6 +49,9 @@
 #include <syscall.h>
 #include <test.h>
 #include <version.h>
+#include "file.h"
+#include "fdtable.h"
+/* #include <file_table.h> */
 #include "autoconf.h"  // for pseudoconfig
 
 
@@ -68,8 +71,8 @@ extern const char buildconfig[];
  * Copyright message for the OS/161 base code.
  */
 static const char harvard_copyright[] =
-    "Copyright (c) 2000, 2001-2005, 2008-2011, 2013, 2014\n"
-    "   President and Fellows of Harvard College.  All rights reserved.\n";
+"Copyright (c) 2000, 2001-2005, 2008-2011, 2013, 2014\n"
+"   President and Fellows of Harvard College.  All rights reserved.\n";
 
 
 /*
@@ -79,66 +82,70 @@ static
 void
 boot(void)
 {
-	/*
-	 * The order of these is important!
-	 * Don't go changing it without thinking about the consequences.
-	 *
-	 * Among other things, be aware that console output gets
-	 * buffered up at first and does not actually appear until
-	 * mainbus_bootstrap() attaches the console device. This can
-	 * be remarkably confusing if a bug occurs at this point. So
-	 * don't put new code before mainbus_bootstrap if you don't
-	 * absolutely have to.
-	 *
-	 * Also note that the buffer for this is only 1k. If you
-	 * overflow it, the system will crash without printing
-	 * anything at all. You can make it larger though (it's in
-	 * dev/generic/console.c).
-	 */
-
-	kprintf("\n");
-	kprintf("OS/161 base system version %s\n", BASE_VERSION);
-	kprintf("(with locks&CVs solution)\n");
-	kprintf("%s", harvard_copyright);
-	kprintf("\n");
-
-	kprintf("Put-your-group-name-here's system version %s (%s #%d)\n",
-		GROUP_VERSION, buildconfig, buildversion);
-	kprintf("\n");
-
-	/* Early initialization. */
-	ram_bootstrap();
-	proc_bootstrap();
-	thread_bootstrap();
-	hardclock_bootstrap();
-	vfs_bootstrap();
-	kheap_nextgeneration();
-
-	/* Probe and initialize devices. Interrupts should come on. */
-	kprintf("Device probe...\n");
-	KASSERT(curthread->t_curspl > 0);
-	mainbus_bootstrap();
-	KASSERT(curthread->t_curspl == 0);
-	/* Now do pseudo-devices. */
-	pseudoconfig();
-	kprintf("\n");
-	kheap_nextgeneration();
-
-	/* Late phase of initialization. */
-	vm_bootstrap();
-	kprintf_bootstrap();
-	thread_start_cpus();
-
-	/* Default bootfs - but ignore failure, in case emu0 doesn't exist */
-	vfs_setbootfs("emu0");
-
-	kheap_nextgeneration();
-
-	/*
-	 * Make sure various things aren't screwed up.
-	 */
-	COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
-	COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
+    /*
+     * The order of these is important!
+     * Don't go changing it without thinking about the consequences.
+     *
+     * Among other things, be aware that console output gets
+     * buffered up at first and does not actually appear until
+     * mainbus_bootstrap() attaches the console device. This can
+     * be remarkably confusing if a bug occurs at this point. So
+     * don't put new code before mainbus_bootstrap if you don't
+     * absolutely have to.
+     *
+     * Also note that the buffer for this is only 1k. If you
+     * overflow it, the system will crash without printing
+     * anything at all. You can make it larger though (it's in
+     * dev/generic/console.c).
+     */
+
+    kprintf("\n");
+    kprintf("OS/161 base system version %s\n", BASE_VERSION);
+    kprintf("(with locks&CVs solution)\n");
+    kprintf("%s", harvard_copyright);
+    kprintf("\n");
+
+    kprintf("Put-your-group-name-here's system version %s (%s #%d)\n",
+            GROUP_VERSION, buildconfig, buildversion);
+    kprintf("\n");
+
+    /* Early initialization. */
+    ram_bootstrap();
+    init_kern_file_table();
+    proc_bootstrap();
+    thread_bootstrap();
+    hardclock_bootstrap();
+    vfs_bootstrap();
+    kheap_nextgeneration();
+
+    /* Probe and initialize devices. Interrupts should come on. */
+    kprintf("Device probe...\n");
+    KASSERT(curthread->t_curspl > 0);
+    mainbus_bootstrap();
+    KASSERT(curthread->t_curspl == 0);
+    /* Now do pseudo-devices. */
+    pseudoconfig();
+    kprintf("\n");
+    kheap_nextgeneration();
+
+    /* Late phase of initialization. */
+    vm_bootstrap();
+    kprintf_bootstrap();
+    thread_start_cpus();
+
+    /* Default bootfs - but ignore failure, in case emu0 doesn't exist */
+    vfs_setbootfs("emu0");
+
+    /*initial STDIN STDOU STDERR, should be inited after the init of file system */
+    init_stdio(get_current_proc()->fs_struct);
+
+    kheap_nextgeneration();
+
+    /*
+     * Make sure various things aren't screwed up.
+     */
+    COMPILE_ASSERT(sizeof(userptr_t) == sizeof(char *));
+    COMPILE_ASSERT(sizeof(*(userptr_t)0) == sizeof(char));
 }
 
 /*
@@ -149,15 +156,20 @@ void
 shutdown(void)
 {
 
-	kprintf("Shutting down.\n");
+    kprintf("Shutting down.\n");
 
-	vfs_clearbootfs();
-	vfs_clearcurdir();
-	vfs_unmountall();
 
-	thread_shutdown();
+    vfs_clearbootfs();
+    vfs_clearcurdir();
+    vfs_unmountall();
 
-	splhigh();
+    thread_shutdown();
+
+    destroy_fd_table(get_current_proc());
+    /* proc_shutdown(); */
+    destroy_kern_file_table();
+
+    splhigh();
 }
 
 /*****************************************/
@@ -172,34 +184,34 @@ shutdown(void)
 int
 sys_reboot(int code)
 {
-	switch (code) {
-		case RB_REBOOT:
-		case RB_HALT:
-		case RB_POWEROFF:
-			break;
-		default:
-			return EINVAL;
-	}
-
-	shutdown();
-
-	switch (code) {
-		case RB_HALT:
-			kprintf("The system is halted.\n");
-			mainbus_halt();
-			break;
-		case RB_REBOOT:
-			kprintf("Rebooting...\n");
-			mainbus_reboot();
-			break;
-		case RB_POWEROFF:
-			kprintf("The system is halted.\n");
-			mainbus_poweroff();
-			break;
-	}
-
-	panic("reboot operation failed\n");
-	return 0;
+    switch (code) {
+        case RB_REBOOT:
+        case RB_HALT:
+        case RB_POWEROFF:
+            break;
+        default:
+            return EINVAL;
+    }
+
+    shutdown();
+
+    switch (code) {
+        case RB_HALT:
+            kprintf("The system is halted.\n");
+            mainbus_halt();
+            break;
+        case RB_REBOOT:
+            kprintf("Rebooting...\n");
+            mainbus_reboot();
+            break;
+        case RB_POWEROFF:
+            kprintf("The system is halted.\n");
+            mainbus_poweroff();
+            break;
+    }
+
+    panic("reboot operation failed\n");
+    return 0;
 }
 
 /*
@@ -209,9 +221,9 @@ sys_reboot(int code)
 void
 kmain(char *arguments)
 {
-	boot();
+    boot();
 
-	menu(arguments);
+    menu(arguments);
 
-	/* Should not get here */
+    /* Should not get here */
 }
diff --git kern/main/menu.c kern/main/menu.c
index 54e912e..2beacf4 100644
--- kern/main/menu.c
+++ kern/main/menu.c
@@ -705,6 +705,11 @@ static struct {
 	{ "fs5",	longstress },
 	{ "fs6",	createstress },
 
+
+
+
+    {"fs_mt", file_multithread_test},
+
 	{ NULL, NULL }
 };
 
diff --git kern/proc/proc.c kern/proc/proc.c
index 2db8ea2..555cfb4 100644
--- kern/proc/proc.c
+++ kern/proc/proc.c
@@ -48,6 +48,8 @@
 #include <current.h>
 #include <addrspace.h>
 #include <vnode.h>
+#include <fdtable.h>
+/* #include <file_table.h> */
 
 /*
  * The process for the kernel; this holds all the kernel-only threads.
@@ -82,6 +84,16 @@ proc_create(const char *name)
 	/* VFS fields */
 	proc->p_cwd = NULL;
 
+    int ret = init_fd_table(proc);
+    if (ret != 0)
+    {
+        spinlock_cleanup(&proc->p_lock);
+        kfree(proc->p_name);
+        kfree(proc);
+        return NULL;
+    }
+
+
 	return proc;
 }
 
@@ -105,6 +117,8 @@ proc_destroy(struct proc *proc)
 	KASSERT(proc != NULL);
 	KASSERT(proc != kproc);
 
+
+    destroy_fd_table(proc);
 	/*
 	 * We don't take p_lock in here because we must have the only
 	 * reference to this structure. (Otherwise it would be
@@ -199,6 +213,8 @@ proc_create_runprogram(const char *name)
 	if (newproc == NULL) {
 		return NULL;
 	}
+    init_stdio(newproc->fs_struct);
+    /* setup_process_stdio(newproc); */
 
 	/* VM fields */
 
@@ -300,6 +316,13 @@ proc_getas(void)
 	return as;
 }
 
+struct proc* get_current_proc()
+{
+    KASSERT( curthread->t_proc != NULL );
+    return  curthread->t_proc;
+
+}
+
 /*
  * Change the address space of (the current) process. Return the old
  * one for later restoration or disposal.
@@ -318,3 +341,5 @@ proc_setas(struct addrspace *newas)
 	spinlock_release(&proc->p_lock);
 	return oldas;
 }
+/* struct proc* get_current_proc(); */
+
diff --git kern/syscall/fdtable.c kern/syscall/fdtable.c
new file mode 100644
index 0000000..f5d3fbb
--- /dev/null
+++ kern/syscall/fdtable.c
@@ -0,0 +1,486 @@
+#include <types.h>
+#include <kern/seek.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <uio.h>
+#include <proc.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vnode.h>
+#include <elf.h>
+
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <proc.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+
+#include <types.h>
+#include <copyinout.h>
+#include <syscall.h>
+
+#include <vnode.h>
+#include <debug_print.h>
+#include <proc.h>
+#include "membar.h"
+#include "fdtable.h"
+#include "file.h"
+
+
+static int get_rightmost_zero_bit(unsigned int in)
+{
+    return ((~in) & (in + 1));
+}
+static int __get_bit(int nr, volatile void * addr)
+{
+    KASSERT(nr >= 0);
+     int *m = ((int *) addr) + (nr >> 5);
+     int ret = (*m &( 1 << (nr & 31)));
+     membar_any_any();
+     return ret;
+}
+/*
+ * >=0 success, < 0 indicates the errno
+ */
+
+/* static int bit_2_index[8] = {}; */
+static int find_next_fd(struct fdtable *fdt)
+{
+    int fd = 0;
+    for (size_t i = 0; i < fdt->max_fds / FD_BITS ; i ++)
+    {
+        int bit = get_rightmost_zero_bit(fdt->open_fds_bits[i]);
+        if (bit != 0)
+        {
+            for (size_t j = 0; j < FD_BITS; j ++)
+            {
+                if ((1 << j) == bit)
+                {
+                    return fd + j;
+                }
+
+            }
+        }
+        fd += FD_BITS;
+    }
+    return -1;
+}
+static struct file* __fd_check(struct files_struct* fst, int fd)
+{
+    KASSERT(spinlock_do_i_hold(&(fst->file_lock)));
+
+    if (is_valid_fd(fst, fd) && fst->fdt->fd_array[fd] != NULL)
+    {
+        KASSERT(__get_bit(fd, fst->fdt->open_fds_bits)  !=  0);
+        return fst->fdt->fd_array[fd];
+    }
+    else
+    {
+        return NULL;
+    }
+}
+static void __set_bit(int nr, volatile void * addr)
+{
+    KASSERT(nr >= 0);
+     int *m = ((int *) addr) + (nr >> 5);
+     *m |= 1 << (nr & 31);
+     membar_any_any();
+}
+static void __clear_bit(int nr, volatile void * addr)
+{
+    KASSERT(nr >= 0);
+     int *m = ((int *) addr) + (nr >> 5);
+     *m &= ~(1 << (nr & 31));
+     /* DEBUG_PRINT("nr: %d, index: %d, bit: %d\n", nr, (nr >> 5), 1 << (nr & 31)); */
+     membar_any_any();
+}
+static void __set_open_fd(int fd,  struct fdtable *fdt)
+{
+    __set_bit(fd, fdt->open_fds_bits);
+}
+/*
+ * currently only support fixed count fd, TODO reallocate fd array if filled up
+ */
+static int __alloc_fd(struct files_struct* files)
+{
+    KASSERT(files != NULL);
+    int fd;
+    spinlock_acquire(&(files->file_lock));
+    struct fdtable* fdt = files->fdt;
+    fd = find_next_fd(fdt);
+    if (fd < 0)
+    {
+        spinlock_release(&(files->file_lock));
+        return -EMFILE;
+    }
+    __set_open_fd(fd, fdt);
+    spinlock_release(&(files->file_lock));
+    return fd;
+}
+static void __put_unused_fd(struct files_struct* files, int fd)
+{
+    struct fdtable *fdt = files->fdt;
+    __clear_bit(fd, fdt->open_fds_bits);
+    return;
+}
+
+
+static int __close_fd(struct files_struct* files, int fd)
+{
+    if (fd < 0)
+    {
+        return -EBADF;
+    }
+    struct fdtable *fdt;
+    struct file *file;
+    spinlock_acquire(&(files->file_lock));
+    fdt = files->fdt;
+    if (fd >=(int) fdt->max_fds)
+    {
+        spinlock_release(&(files->file_lock));
+        return -EBADF;
+    }
+    file = __fd_check(files, fd);
+    if (file == NULL)
+    {
+        spinlock_release(&(files->file_lock));
+        return -EBADF;
+    }
+    /* file = fdt->fd_array[fd]; */
+    KASSERT(file != NULL);
+    fdt->fd_array[fd] = NULL;
+    __put_unused_fd(files, fd);
+    return close_kern_file(file, &(files->file_lock));
+}
+static void __fd_install(struct files_struct* fst, int fd, struct file* fp)
+{
+    KASSERT(fp != NULL);
+    KASSERT(fd >= 0);
+    KASSERT(fd < (int)fst->fdt->max_fds);
+    KASSERT(fst->fdt->fd_array[fd] == NULL);
+    KASSERT(__get_bit(fd, fst->fdt->open_fds_bits) != 0);
+    fst->fdt->fd_array[fd] = fp;
+    return;
+}
+
+/*
+ * there is intermediate status which is:
+ * open_fd_used has been marked 1,
+ * but the file pointer has not been installed in fd array
+ *
+ */
+int do_sys_open(int dfd, void* filename, int flags, mode_t mode, struct files_struct* fst)
+{
+    /* struct files_struct* fst = get_current_proc()->fs_struct; */
+    KASSERT(fst != NULL);
+    int fd = __alloc_fd(fst);
+    if (fd < 0)
+    {
+        DEBUG_PRINT("allocate fd error, while opening: %s\n", (char*)filename);
+        return fd;
+    }
+    struct file* fp = NULL;
+    int ret  = do_flip_open(&fp, dfd, filename, flags, mode);
+    if ( ret != 0)
+    {
+        DEBUG_PRINT("do flip open error, while opening: %s, put back fd: %d\n", (char*)filename, fd);
+        __put_unused_fd(fst, fd);
+        KASSERT(ret < 0);
+        return ret;
+    }
+    else
+    {
+        __fd_install(fst, fd, fp);
+    }
+    /* DEBUG_PRINT("do open %s, %d success\n", (char*)filename, fd); */
+    return fd;
+}
+int do_sys_close(int fd)
+{
+    return __close_fd(get_current_proc()->fs_struct, fd);
+}
+
+
+static int __dup2(struct files_struct* fst, struct file* f, int newfd)
+{
+    KASSERT(spinlock_do_i_hold(&(fst->file_lock)));
+    struct fdtable *fdt;
+    fdt = fst->fdt;
+    struct file* tofree =  fdt->fd_array[newfd];
+    /*
+     * imtermediate status
+     */
+    if (tofree == NULL && __get_bit(newfd, fdt->open_fds_bits ) != 0)
+    {
+        spinlock_release(&(fst->file_lock));
+        return -EBUSY;
+    }
+    /* KASSERT(tofree == NULL); */
+    /* KASSERT(__get_bit(newfd, fdt->open_fds_bits) == 0); */
+    inc_ref_file(f);
+    fdt->fd_array[newfd] = f;
+    __set_open_fd(newfd, fdt);
+    spinlock_release(&(fst->file_lock));
+    if (tofree != NULL)
+    {
+        spinlock_acquire(&(fst->file_lock));
+        close_kern_file(tofree, &(fst->file_lock));
+    }
+    return 0;
+
+}
+int do_sys_dup2(int oldfd, int newfd)
+{
+    if (oldfd == newfd)
+    {
+        return -EINVAL;
+    }
+    struct files_struct* fst = get_current_proc()->fs_struct;
+    if (is_valid_fd(fst, oldfd) == 0 ||
+        is_valid_fd(fst, newfd) == 0)
+    {
+        return -EBADF;
+    }
+    spinlock_acquire(&(fst->file_lock));
+    struct file* f = __fd_check(fst, oldfd);
+    if (f == NULL)
+    {
+        spinlock_release(&(fst->file_lock));
+        return -EBADF;
+    }
+    /* spinlock of file_lock should be released inside __dup2 */
+    return  __dup2(fst, f, newfd);
+
+}
+
+off_t do_sys_lseek(int fd, off_t pos, int whence)
+{
+    if (whence != SEEK_SET
+        && whence != SEEK_CUR
+        && whence != SEEK_END)
+    {
+        return -EINVAL;
+    }
+    struct files_struct* fst = get_current_proc()->fs_struct;
+    if (is_valid_fd(fst,fd) == 0)
+    {
+        return -EBADF;
+    }
+
+    spinlock_acquire(&(fst->file_lock));
+    struct file* f = __fd_check(fst, fd);
+    if (f == NULL)
+    {
+        spinlock_release(&(fst->file_lock));
+        return -EBADF;
+    }
+
+    /* a trick played here
+     * I have some operation on this file handler, although some other threads may close this file handler via fd, but this file handler would not be released after the operations finished.
+     */
+    inc_ref_file(f);
+
+    spinlock_release(&(fst->file_lock));
+
+    off_t ret = kern_file_seek(f, pos, whence);
+    spinlock_acquire(&(fst->file_lock));
+    if ( ret < 0)
+    {
+        close_kern_file(f, &(fst->file_lock));
+        return ret;
+    }
+
+    close_kern_file(f, &(fst->file_lock));
+    return ret;
+
+}
+int do_sys_read(int fd, char* buf, size_t buf_len)
+{
+
+    struct files_struct* fst = get_current_proc()->fs_struct;
+    if (is_valid_fd(fst, fd) == 0)
+    {
+        return -EBADF;
+    }
+
+    spinlock_acquire(&(fst->file_lock));
+    struct file* f = __fd_check(fst, fd);
+    if (f == NULL)
+    {
+        spinlock_release(&(fst->file_lock));
+        return -EBADF;
+    }
+    inc_ref_file(f);
+    spinlock_release(&(fst->file_lock));
+    size_t read_len = 0;
+    int ret = kern_file_read(f, buf, buf_len, &read_len);
+    spinlock_acquire(&(fst->file_lock));
+    if ( ret != 0)
+    {
+        close_kern_file(f, &(fst->file_lock));
+        KASSERT(ret < 0);
+        return ret;
+    }
+
+    close_kern_file(f, &(fst->file_lock));
+    return read_len;
+
+}
+ssize_t do_sys_write(int fd, const void *buf, size_t buf_len)
+{
+
+    struct files_struct* fst = get_current_proc()->fs_struct;
+    if (is_valid_fd(fst, fd) == 0)
+    {
+        return -EBADF;
+    }
+
+    spinlock_acquire(&(fst->file_lock));
+    struct file* f = __fd_check(fst, fd);
+    if (f == NULL)
+    {
+        spinlock_release(&(fst->file_lock));
+        return -EBADF;
+    }
+    inc_ref_file(f);
+    spinlock_release(&(fst->file_lock));
+    size_t write_len= 0;
+    int ret = kern_file_write(f, buf, buf_len, & write_len);
+    spinlock_acquire(&(fst->file_lock));
+    if (ret != 0)
+    {
+        close_kern_file(f, &(fst->file_lock));
+        KASSERT(ret < 0);
+        return ret;
+    }
+
+    close_kern_file(f, &(fst->file_lock));
+    return write_len;
+
+
+}
+
+
+static void __destroy_fdt(struct fdtable* fdt, struct files_struct* fst)
+{
+    for (size_t i = 0; i < fdt->max_fds; i ++)
+    {
+        if (__get_bit(i, fdt->open_fds_bits) )
+        {
+            KASSERT(fdt->fd_array[i] != NULL);
+            spinlock_acquire(&(fst->file_lock));
+            close_kern_file(fdt->fd_array[i], &(fst->file_lock));
+            fdt->fd_array[i] = NULL;
+            __clear_bit(i, fdt->open_fds_bits);
+        }
+
+    }
+    kfree(fdt->fd_array);
+    kfree((void*)fdt->open_fds_bits);
+    return;
+}
+static int __init_fdt(struct fdtable* fdt)
+{
+    KASSERT(fdt != NULL);
+    fdt->max_fds = MAX_FD_COUNT_PER_PROCESS;
+    fdt->fd_array = kmalloc(MAX_FD_COUNT_PER_PROCESS * sizeof(struct file*));
+    if (fdt->fd_array == NULL)
+    {
+        return -1;
+    }
+    fdt->open_fds_bits = kmalloc(MAX_FD_COUNT_PER_PROCESS/FD_BITS * (sizeof(unsigned int)));
+    if (fdt->open_fds_bits == NULL)
+    {
+        kfree(fdt->fd_array);
+        return -1;
+    }
+    for (size_t i = 0; i < MAX_FD_COUNT_PER_PROCESS/FD_BITS; i ++)
+    {
+        fdt->open_fds_bits[i] = 0;
+        fdt->fd_array[i] = NULL;
+    }
+    return 0;
+}
+int init_stdio(struct files_struct* fst)
+{
+    /* (void)fst; */
+    int ret = do_sys_open(0, NULL, 0, 0, fst);
+    if ( ret < 0)
+    {
+        return ret;
+    }
+
+    ret = do_sys_open(1, NULL, 0, 0, fst);
+    if ( ret < 0)
+    {
+        return ret;
+    }
+
+    ret = do_sys_open(2, NULL, 0, 0, fst);
+    if ( ret < 0)
+    {
+        return ret;
+    }
+
+    return 0;
+}
+
+int init_fd_table(struct proc* cur)
+{
+
+    KASSERT(cur != NULL);
+    cur->fs_struct = kmalloc(sizeof(*(cur->fs_struct)));
+    if (cur->fs_struct == NULL)
+    {
+        return ENOMEM;
+    }
+    spinlock_init(&(cur->fs_struct->file_lock));
+    cur->fs_struct->fdt = kmalloc(sizeof((*cur->fs_struct->fdt)));
+    if (cur->fs_struct->fdt == NULL)
+    {
+        spinlock_cleanup(&(cur->fs_struct->file_lock));
+        kfree(cur->fs_struct);
+        cur->fs_struct = NULL;
+        return ENOMEM;
+    }
+    int ret = __init_fdt(cur->fs_struct->fdt);
+    if (ret != 0)
+    {
+        kfree(cur->fs_struct->fdt);
+        spinlock_cleanup(&(cur->fs_struct->file_lock));
+        kfree(cur->fs_struct);
+        cur->fs_struct = NULL;
+        return ENOMEM;
+    }
+    /* ret = __init_stdio(cur->fs_struct); */
+    /* if ( ret != 0) */
+    /* { */
+    /*     __destroy_fdt(cur->fs_struct->fdt); */
+    /*     kfree(cur->fs_struct->fdt); */
+    /*     spinlock_cleanup(&(cur->fs_struct->file_lock)); */
+    /*     kfree(cur->fs_struct); */
+    /*     cur->fs_struct = NULL; */
+    /*     return ret; */
+    /* } */
+
+    return 0;
+}
+
+void destroy_fd_table(struct proc* proc)
+{
+    KASSERT(proc != NULL);
+    /* spinlock_acquire(&(proc->fs_struct->file_lock)); */
+    struct fdtable* fdt = proc->fs_struct->fdt;
+    __destroy_fdt(fdt, proc->fs_struct);
+    /* spinlock_release(&(proc->fs_struct->file_lock)); */
+    spinlock_cleanup(&(proc->fs_struct->file_lock));
+    kfree(proc->fs_struct->fdt);
+    kfree(proc->fs_struct);
+    return;
+}
diff --git kern/syscall/file.c kern/syscall/file.c
index 11ffcb9..1dce61c 100644
--- kern/syscall/file.c
+++ kern/syscall/file.c
@@ -1,21 +1,172 @@
+/**
+ * @file:   file.c
+ * @brief:  implementation of io syscalls, open, write, close, lseek, dup2
+ * @author: bladechen(chenshenglong1990@gmail.com)
+ *
+ * 2016-12-10
+ */
 #include <types.h>
-#include <kern/errno.h>
-#include <kern/fcntl.h>
-#include <kern/limits.h>
-#include <kern/stat.h>
-#include <kern/seek.h>
+#include <copyinout.h>
+#include <syscall.h>
 #include <lib.h>
+#include <kern/errno.h>
 #include <uio.h>
-#include <thread.h>
+#include <proc.h>
 #include <current.h>
-#include <synch.h>
-#include <vfs.h>
+#include <addrspace.h>
 #include <vnode.h>
-#include <file.h>
-#include <syscall.h>
-#include <copyinout.h>
 
-/*
- * Add your file-related functions here ...
- */
+#include <debug_print.h>
+#include "fdtable.h"
+
+#define MAX_FILENAME_LENGTH 128
+
+int syscall_open(const_userptr_t filename, int flags, mode_t mode, int* fd_num)
+{
+    int result = 0;
+    void* tmp_filename = kmalloc(MAX_FILENAME_LENGTH);
+    size_t tmp_filename_len = 0;
+
+    if (tmp_filename == NULL)
+    {
+        DEBUG_PRINT("no enough kernel mem\n");
+        * fd_num = ENOMEM;
+        return -1;
+    }
+
+    result = copyinstr(filename, tmp_filename, MAX_FILENAME_LENGTH - 1, & tmp_filename_len);
+    if (result != 0)
+    {
+        DEBUG_PRINT("copy open filename to kernel buf error: %d\n", result);
+        kfree(tmp_filename);
+        *fd_num = result;
+        return -1;
+    }
+    kprintf("copy filename success: %s\n", (char*)tmp_filename);
+    result  = do_sys_open(-1, tmp_filename, flags, mode, get_current_proc()->fs_struct);
+    kfree(tmp_filename);
+    if (result < 0)
+    {
+        *fd_num = result;
+        return -1;
+    }
+    *fd_num = result;
+    return 0;
+}
+
+int syscall_close(int fd_num, int* retval)
+{
+    *retval = do_sys_close(fd_num);
+    return (*retval == 0 )? 0 : -1;
+}
+int syscall_read(int fd, userptr_t buf, size_t buflen, size_t* retval)
+{
+
+    DEBUG_PRINT("fd: %d, read\n", fd);
+    void*  tmp_kern_buf = kmalloc(buflen + 1);
+
+    if (tmp_kern_buf == NULL)
+    {
+        kprintf ("no enough kernel mem\n");
+        *retval  = ENOMEM;
+        /* return -ENOMEM; */
+        return -1;
+    }
+
+    int result = do_sys_read(fd, tmp_kern_buf, buflen);
+    if (result < 0)
+    {
+        kprintf ("do sys read errorn\n");
+        kfree(tmp_kern_buf);
+        *retval = -result;
+        return -1;
+    }
+    if (result == 0)
+    {
+        kfree(tmp_kern_buf);
+        *retval = result;
+        return 0;
+    }
+
+/* int */
+/* copyoutstr(const char *src, userptr_t userdest, size_t len, size_t *actual) */
+
+    *retval  = result;
+    result = copyout(tmp_kern_buf, buf, result);
+    if (result != 0)
+    {
+        kfree(tmp_kern_buf);
+        *retval = result;
+        return -1;
+    }
+    kfree(tmp_kern_buf);
+    return 0;
+}
+
+int syscall_write(int fd,  const_userptr_t buf, size_t nbytes, size_t* retval)
+{
+
+    if (nbytes == 0)
+    {
+        int result = do_sys_write(fd, NULL, 0);
+        *retval = result;
+        return (*retval == 0)? 0: -1;
+
+    }
+    /* size_t tmp_kern_buflen = nbytes + 1; */
+    /* if (nbytes) */
+    char*  tmp_kern_buf = kmalloc(nbytes + 1);
+
+    if (tmp_kern_buf == NULL)
+    {
+        kprintf ("no enough kernel mem\n");
+        *retval = ENOMEM;
+        return -1;
+    }
+
+    int result = copyin(buf, tmp_kern_buf,  nbytes);
+    if (result != 0)
+    {
+        kprintf ("copy write user buf to  kernel buf error: %d\n", result);
+        kfree(tmp_kern_buf);
+        *retval = result;
+        return -1;
+    }
+    tmp_kern_buf[nbytes] = 0;
+    /* kprintf ("copyin[%s], %d\n", (char*) tmp_kern_buf, nbytes); */
+    result = do_sys_write(fd, tmp_kern_buf, nbytes);
+    if (result < 0)
+    {
+        kfree(tmp_kern_buf);
+        *retval = - result;
+        return -1;
+    }
+    *retval = result;
+    kfree(tmp_kern_buf);
+    return 0;
+}
+int syscall_lseek(int fd, off_t pos, int whence, off_t* retval)
+{
+    *retval = 0;
+    off_t r = do_sys_lseek(fd, pos, whence);
+    if (r < 0)
+    {
+        *retval = -r;
+        return -1;
+    }
+    KASSERT(r >= 0);
+    *retval = r;
+    return 0;
+
+}
+int syscall_dup2(int oldfd, int newfd, int* retval)
+{
+    *retval  = do_sys_dup2(oldfd, newfd);
+    return (*retval == 0)? 0: -1;
 
+}
+/* int syscall_write(int fd_num, const_userptr_t* buf, size_t length) */
+/* { */
+/*     int written_length = 0; */
+/*     return written_length; */
+/* } */
diff --git kern/syscall/kern_file.c kern/syscall/kern_file.c
new file mode 100644
index 0000000..fa21c71
--- /dev/null
+++ kern/syscall/kern_file.c
@@ -0,0 +1,380 @@
+#include <types.h>
+#include <kern/errno.h>
+#include <lib.h>
+#include <uio.h>
+#include <proc.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vnode.h>
+#include <elf.h>
+#include "kern/unistd.h"
+
+
+#include <types.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <proc.h>
+#include <current.h>
+#include <addrspace.h>
+#include <vm.h>
+#include <vfs.h>
+#include <syscall.h>
+
+#include <types.h>
+#include "vfs.h"
+
+#include <kern/seek.h>
+#include "file.h"
+#include "mips/atomic.h"
+#include "list.h"
+#include "debug_print.h"
+
+static struct files_table g_ftb;
+
+void init_kern_file_table(void)
+{
+    spinlock_init(&(g_ftb.files_table_lock));
+    g_ftb.list_obj = init_list(offsetof(struct file, link_obj));
+    if (g_ftb.list_obj == NULL)
+    {
+        panic("init kern file list error");
+    }
+    return;
+}
+void destroy_kern_file_table(void)
+{
+    // the list should be empty, after all the process' fd table finishing cleaning
+    KASSERT(is_list_empty(g_ftb.list_obj) == 1);
+    destroy_list(g_ftb.list_obj);
+    spinlock_cleanup(&(g_ftb.files_table_lock) );
+    return;
+}
+
+static int get_file_stat(struct file* node)
+{
+    KASSERT(node != NULL);
+    int result = 0;
+
+    result = VOP_STAT(node->v_ptr, &(node->f_stat));
+    if ( result != 0)
+    {
+        return -result;
+    }
+    if (node->f_flags& O_APPEND)
+    {
+        node->f_pos = node->f_stat.st_size;
+    }
+    return 0;
+}
+
+
+static void __destroy_kern_file(struct file* fs)
+{
+    KASSERT(fs != NULL);
+    KASSERT(fs->ref_count == 0);
+    KASSERT(is_linked(&(fs->link_obj)) == 0);
+
+    if (fs->v_ptr != NULL)
+    {
+        /*
+         * need flush file, but ... sys161
+         */
+        vfs_close(fs->v_ptr);
+        fs->v_ptr = NULL;
+    }
+    kfree (fs);
+
+    return;
+}
+
+int close_kern_file(struct file* fs, struct spinlock* fs_lock)
+{
+    KASSERT(fs != NULL);
+    KASSERT(fs_lock != NULL);
+    KASSERT(spinlock_do_i_hold(fs_lock));
+
+    /*
+     * when ref is >= 1, so do nothing but dec ref by 1
+     */
+    // using atomic can avoid race condition happened in vnode_decref/emufs_reclaim
+    // but we still need spinlock to protect, because one guy may call close_kern_file, and go to 109 line(switeched out), another guy may at fdtable.c:313 which is before inc_ref
+    if (mb_atomic_cmpxchg_dec_to_target(&(fs->ref_count), 0) == 0)
+    {
+        spinlock_release(fs_lock);
+        return 0;
+    }
+    else
+    {
+        spinlock_release(fs_lock);
+        struct files_table* ftb = fs->owner;
+        KASSERT(fs->owner != NULL);
+
+        spinlock_acquire(&(ftb->files_table_lock));
+
+        KASSERT(fs->ref_count == 0);
+        link_detach(fs, link_obj);
+        fs->owner = NULL;
+
+        /*
+         * no one
+         */
+        struct vnode* v_tmp = fs->v_ptr;
+        fs->v_ptr = NULL;
+        __destroy_kern_file(fs);
+        spinlock_release(&(ftb->files_table_lock));
+        if (v_tmp != NULL)
+        {
+            vfs_close(v_tmp);
+        }
+
+    }
+    return 0;
+
+}
+static int __init_kern_file(struct file** retval, struct vnode* v, struct fs* f, int flags, mode_t mode)
+{
+
+    (void)f;
+    struct file *node = kmalloc(sizeof(struct file));
+    if (node == NULL)
+    {
+        return -ENOMEM;
+    }
+    node->file_op_lock =lock_create(" a file lock");
+    if ( node->file_op_lock == NULL)
+    {
+        kfree(node);
+        return -ENOMEM;
+    }
+    (void) mode;
+    KASSERT(node != NULL);
+    link_init(&node->link_obj);
+    node->ref_count = 1;
+    node->v_ptr = v;
+    node->f_flags = flags;
+    node->f_pos = 0;
+    node->owner = &g_ftb;
+    *retval = node;
+    return 0;
+}
+static int __do_stdio_open(struct file** f, int fd)
+{
+    char con[10] = "con:";
+    struct file* tmp;
+    *f = NULL;
+    int flags = (fd == 0? O_RDONLY: O_WRONLY);
+    struct vnode* v;
+
+    int ret = 0;
+    ret = vfs_open(con, flags, 0, &v);
+    if (ret != 0)
+    {
+        DEBUG_PRINT("vfs_open: std[%d] failed\n", fd);
+        return -ret ;
+    }
+
+    ret = __init_kern_file(&tmp, v, NULL, flags, 0);
+    if (ret != 0)
+    {
+
+        DEBUG_PRINT("vfs_open: std[%d] failed, vm not enough\n", fd);
+        vfs_close(v);
+        return ret;
+    }
+    spinlock_acquire(&(g_ftb.files_table_lock));
+    list_insert_tail(g_ftb.list_obj, tmp);
+    spinlock_release(&(g_ftb.files_table_lock));
+
+    *f = tmp;
+    return 0;
+}
+int do_flip_open(struct file ** fp, int dfd, char* filename,int flags, mode_t mode )
+{
+    if (dfd == STDIN_FILENO || dfd == STDOUT_FILENO || dfd  == STDERR_FILENO)
+    {
+        return __do_stdio_open(fp, dfd);
+
+    }
+    struct vnode *v = NULL;
+    struct file* node;
+
+    int ret = vfs_open(filename, flags, mode, &v);
+    if (ret != 0)
+    {
+        DEBUG_PRINT("vfs_open open file: [%s], flags: [%d], mode: [%d], failed: %d",
+                 filename, flags, mode, ret);
+        return -ret;
+    }
+    /* DEBUG_PRINT("%p\n", v); */
+    KASSERT(v != NULL);
+    ret = __init_kern_file(&node, v, NULL, flags, mode);
+    if (ret != 0)
+    {
+        DEBUG_PRINT("vfs_open open file: [%s], flags: [%d], mode: [%d], failed at init_file: %d\n",
+                 filename, flags, mode, ret);
+        vfs_close(v);
+        return ret;
+    }
+
+    ret = get_file_stat(node);
+    if (ret != 0)
+    {
+        __destroy_kern_file(node);
+        return ret ;
+    }
+
+    spinlock_acquire(&(g_ftb.files_table_lock));
+    list_insert_tail(g_ftb.list_obj, node);
+    spinlock_release(&(g_ftb.files_table_lock));
+
+    *fp = node;
+
+    return 0;
+}
+
+void inc_ref_file(struct file* f)
+{
+    mb_atomic_inc_int(&(f->ref_count));
+}
+
+static int __do_file_seek(struct file* f, off_t target_pos)
+{
+    /*
+     * emufs did not have seek api
+     */
+    f->f_pos = target_pos;
+    return 0;
+}
+static bool __is_seekable(struct file * f)
+{
+    return VOP_ISSEEKABLE(f->v_ptr);
+}
+
+off_t kern_file_seek(struct file* f,  off_t pos, int whence)
+{
+    int ret = 0;
+    KASSERT(f != NULL);
+    off_t cur_pos = f->f_pos;
+    KASSERT(cur_pos >= 0);
+    if (__is_seekable(f) == 0)
+    {
+        return -ESPIPE;
+    }
+    lock_acquire(f->file_op_lock);
+    if (whence == SEEK_SET)
+    {
+        if (pos < 0)
+        {
+            ret = -EINVAL;
+            goto end_seek;
+        }
+        else
+        {
+            ret = __do_file_seek(f, pos);
+            goto end_seek;
+        }
+
+    }
+    else if (whence == SEEK_END)
+    {
+        ret = get_file_stat(f);
+        if (ret != 0)
+        {
+            /* ret = -ret; */
+            goto end_seek;
+        }
+        if (f->f_stat.st_size + pos < 0)
+        {
+            ret = -EINVAL;
+            goto end_seek;
+        }
+
+        ret = __do_file_seek(f, f->f_stat.st_size + pos);
+        goto end_seek;
+
+    }
+    else if (whence == SEEK_CUR)
+    {
+        if (f->f_pos + pos < 0)
+        {
+            ret = -EINVAL;
+            goto end_seek;
+        }
+        ret =  __do_file_seek(f, f->f_pos + pos);
+        goto end_seek;
+
+    }
+    else
+    {
+        ret = -EINVAL;
+        goto end_seek;
+    }
+end_seek:
+    lock_release(f->file_op_lock);
+    if (ret < 0)
+    {
+        return ret;
+    }
+    return f->f_pos;
+}
+
+int kern_file_read(struct file* f, char* buf, size_t buf_size, size_t* read_len)
+{
+    if (((f->f_flags & 3) != O_RDONLY) && ((f->f_flags & 3) != O_RDWR))
+    {
+        return -EBADF;
+    }
+    int ret = 0;
+    struct iovec iov;
+    struct uio u;
+    lock_acquire(f->file_op_lock);
+    size_t old = f->f_pos;
+    uio_kinit(&iov, &u, buf, buf_size, f->f_pos, UIO_READ);
+    ret = VOP_READ(f->v_ptr, &u);
+    if (ret != 0)
+    {
+        lock_release(f->file_op_lock);
+        return -ret;
+    }
+    f->f_pos = u.uio_offset;
+    *read_len = f->f_pos - old;
+
+    lock_release(f->file_op_lock);
+    return 0;
+}
+
+int kern_file_write(struct file* f, const void * buf, size_t buf_size, size_t * read_len)
+{
+    if (((f->f_flags & 3) != O_WRONLY) && ((f->f_flags & 3) != O_RDWR))
+    {
+        return -EBADF;
+    }
+    int ret = 0;
+    struct iovec iov;
+    struct uio u;
+    lock_acquire(f->file_op_lock);
+    if (f->f_flags & O_APPEND)
+    {
+        ret = get_file_stat(f);
+        if ( ret != 0)
+        {
+            lock_release(f->file_op_lock);
+            return ret;
+        }
+
+    }
+    size_t old = f->f_pos;
+    uio_kinit(&iov, &u,(void *) buf, buf_size, f->f_pos, UIO_WRITE);
+    ret = VOP_WRITE(f->v_ptr, &u);
+    if (ret != 0)
+    {
+        lock_release(f->file_op_lock);
+        return -ret;
+    }
+    f->f_pos = u.uio_offset;
+    *read_len = f->f_pos - old;
+    lock_release(f->file_op_lock);
+    return 0;
+
+}
diff --git kern/test/file_multithreadtest.c kern/test/file_multithreadtest.c
new file mode 100644
index 0000000..4103976
--- /dev/null
+++ kern/test/file_multithreadtest.c
@@ -0,0 +1,323 @@
+#include <types.h>
+#include <mips/atomic.h>
+#include <kern/errno.h>
+#include <kern/fcntl.h>
+#include <lib.h>
+#include <uio.h>
+#include <proc.h>
+#include <thread.h>
+#include <synch.h>
+#include <vfs.h>
+#include <fs.h>
+#include <vnode.h>
+#include <test.h>
+#include "debug_print.h"
+#include <fdtable.h>
+
+#define NTHREADS 8
+
+int fd_slot[200] = {0};
+
+int fd_owner[200] = {0};
+
+struct lock *fd_slot_lock = NULL;
+struct semaphore *finished;
+
+struct spinlock sp_lock;
+
+int success = 0;
+
+
+volatile int open_count = 0;
+volatile int close_count = 0;
+
+volatile int op_open_count = 0;
+volatile int op_close_count = 0;
+
+
+
+static void multi_open(void * argv1, unsigned long argv2)
+{
+    (void)argv1;
+    (void) argv2;
+    while (1)
+    {
+        int fd =  do_sys_open(-1, (void*)"kern_test_multi_open", O_CREAT, 0, get_current_proc()->fs_struct);
+        if (fd >= 0)
+        {
+            mb_atomic_inc_int(&(fd_slot[fd]));
+          int tmp =   mb_atomic_get_and_set_int(&fd_owner[fd], (int)argv2);
+          if (tmp  != -1)
+          {
+              kprintf(RED "error: fd: %d is occupied by thread num: %d, mine is: %d!!" NONE,
+                      fd, tmp, (int)argv2);
+          }
+
+            kprintf ("thread: %d, open fd: %d\n", (int)argv2, fd);
+           /* lock_acquire(fd_slot_lock); */
+           /* fd_slot[fd] ++; */
+           /* lock_release(fd_slot_lock); */
+
+        }
+        else
+        {
+            kprintf ("thread: %d finished \n", (int)argv2);
+            break;
+        }
+    }
+    V(finished);
+
+    return;
+}
+
+
+void test_open(void);
+void test_open(void)
+{
+
+    kprintf ("begin test_open\n");
+    memset(fd_slot, 0, sizeof(fd_slot));
+    memset(fd_owner, -1, sizeof(fd_owner));
+    membar();
+    success = 1;
+
+    for (int i = 0; i < NTHREADS; i ++)
+    {
+        int ret  = thread_fork("multi_open",
+                                NULL,
+                               &multi_open,
+                               NULL,
+                               i);
+        if ( ret != 0)
+        {
+            panic("thread fork error:%s\n", strerror(ret));
+        }
+
+    }
+    for (int i = 0; i < NTHREADS; i ++)
+    {
+        P(finished);
+    }
+    for (int i = 0; i < MAX_FD_COUNT_PER_PROCESS; i ++)
+    {
+        if (fd_slot[i] >= 2 )
+        {
+            kprintf (RED "error: fd: %d created more than one" NONE, i);
+            success = 0;
+        }
+    }
+    int total = 0;
+    /* int flag = 0; */
+    for (int i = 0; i < MAX_FD_COUNT_PER_PROCESS; i ++)
+    {
+        if (fd_owner[i] != -1)
+        {
+            total ++;
+            kprintf ("fd %d: is occupied by (%d)\n", i, fd_owner[i]);
+
+        }
+        /* else */
+        /* { */
+        /*     kprintf(RED "fd %d is empty\n" NONE, i); */
+        /* } */
+        /*  */
+
+    }
+    if (success == 1)
+    {
+        kprintf(GREEN "passed test, total fd: %d\n" NONE, total);
+    }
+    kprintf ("finish test_open\n");
+    for (int i = 3; i < MAX_FD_COUNT_PER_PROCESS;i ++)
+    {
+        if (fd_slot[i] != -1)
+        {
+            do_sys_close(i);
+        }
+    }
+    return;
+}
+
+static void multi_open_close(void * argv1, unsigned long argv2)
+{
+
+    (void)argv1;
+    (void) argv2;
+    while (1)
+    {
+        if (argv2 >= 2)
+        {
+            /* if (mb_atomic_get_int(&open_count) == 0) */
+            if (mb_atomic_cmpxchg_dec_to_target(&open_count, -1) )
+            {
+                kprintf ("bye, thread: %d, count: %d\n", (int)argv2, op_open_count);
+                break;
+            }
+            int fd = 0;
+continue_open_loop:
+            fd = 0;
+        /* int fd =  do_sys_open(-1, (void*)"kern_test_multi_open", O_CREAT, 0, get_current_proc()->fs_struct); */
+            fd = do_sys_open(-1, (void*)"kern_test_multi_open_close", O_CREAT, 0, get_current_proc()->fs_struct);
+            if (fd >= 0)
+            {
+                spinlock_acquire(&sp_lock);
+                fd_slot[fd] ++;
+                /* mb_atomic_inc_int(&(fd_slot[fd])); */
+                int tmp =  mb_atomic_get_and_set_int(&fd_owner[fd], (int)argv2);
+                if (tmp != -1)
+                {
+                    KASSERT(0);
+                    kprintf(RED "error: fd: %d is occupied by thread num: %d, mine is: %d!!" NONE,
+                            fd, tmp, (int)argv2);
+                }
+                op_open_count ++;
+                spinlock_release(&sp_lock);
+                kprintf ("thread: %d, open fd: %d\n", (int)argv2, fd);
+                /* KASSERT(0); */
+
+            }
+            else
+            {
+                goto continue_open_loop;
+            }
+        }
+        else
+        {
+            if (mb_atomic_cmpxchg_dec_to_target(&close_count, -1) )
+            {
+                break;
+            }
+            int fd = -1;
+continue_close:
+            fd = -1;
+            spinlock_acquire(&sp_lock);
+            for (int i = 0; i < MAX_FD_COUNT_PER_PROCESS;i ++)
+            {
+                if (fd_owner[i] != -1)
+                {
+                    fd = i;
+                    fd_slot[i] -- ;
+                    fd_owner[i] = -1;
+                    op_close_count ++;
+                    break;
+                }
+            }
+            spinlock_release(&sp_lock);
+            if (fd != -1)
+            {
+                KASSERT(do_sys_close(fd) == 0);
+                kprintf ("thread: %d,  close fd: %d, count: %d, %d\n", (int)argv2, fd, op_close_count, close_count);
+
+            }
+            else
+            {
+
+                /* kprintf ("thread: %d, close fd: %d\n", (int)argv2, fd); */
+
+                goto continue_close;
+            }
+
+        }
+    }
+    V(finished);
+
+    return;
+}
+
+
+static void test_open_close(void)
+{
+    kprintf ("begin test_open_close\n");
+    memset(fd_slot, 0, sizeof(fd_slot));
+    memset(fd_owner, -1, sizeof(fd_owner));
+    membar();
+    success = 1;
+    open_count = 100;
+    op_open_count = 0;
+    op_close_count = 0;
+    close_count = 100;
+    do_sys_close(5);
+    do_sys_close(4);
+
+    for (int i = 0; i < NTHREADS; i ++)
+    {
+        int ret  = thread_fork("multi_open_close",
+                                NULL,
+                               &multi_open_close,
+                               NULL,
+                               i);
+        if ( ret != 0)
+        {
+            panic("thread fork error:%s\n", strerror(ret));
+        }
+    }
+    for (int i = 0; i < NTHREADS; i ++)
+    {
+        P(finished);
+    }
+    for (int i = 0; i < MAX_FD_COUNT_PER_PROCESS; i ++)
+    {
+        if (fd_slot[i] >= 2 )
+        {
+            kprintf (RED "error: fd: %d created more than one" NONE, i);
+            success = 0;
+        }
+    }
+    int total = 0;
+    /* int flag = 0; */
+    for (int i = 0; i < MAX_FD_COUNT_PER_PROCESS; i ++)
+    {
+        if (fd_owner[i] != -1)
+        {
+            total ++;
+            kprintf ("fd %d: is occupied by (%d)\n", i, fd_owner[i]);
+
+        }
+        /* else */
+        /* { */
+        /*     kprintf(RED "fd %d is empty\n" NONE, i); */
+        /* } */
+        /*  */
+
+    }
+    if (total == 0)
+    {
+        kprintf(GREEN "passed test, total fd: %d\n" NONE, total);
+    }
+    else
+    {
+
+        kprintf(RED "failed test, total fd: %d\n" NONE, total);
+    }
+    kprintf("open: %d, close: %d\n", op_open_count, op_close_count);
+    kprintf ("finish test_open_close\n");
+
+    return;
+}
+
+int file_multithread_test(int argc, char ** argv)
+{
+    (void) argc;
+    (void) argv;
+    finished = sem_create("finished", 0);
+    if (finished == NULL)
+    {
+        panic("sem_create error\n");
+    }
+
+    fd_slot_lock = lock_create("fd_slot_lock");
+    spinlock_init(&sp_lock);
+
+    if (fd_slot_lock == NULL)
+    {
+        panic("lock_create error\n");
+    }
+
+    /* DEBUG_PRINT("enter file_multithread_test\n"); */
+    test_open();
+    test_open_close();
+    sem_destroy(finished);
+    lock_destroy(fd_slot_lock);
+    spinlock_cleanup(&sp_lock);
+    return 0;
+}
diff --git root_config/.gdbinit root_config/.gdbinit
new file mode 100644
index 0000000..dabbe14
--- /dev/null
+++ root_config/.gdbinit
@@ -0,0 +1,8 @@
+set can-use-hw-watchpoints 0
+define asst2
+dir /Users/Ck/Documents/Masters_UNSW/S1_2017/COMP3231-OS/ass1/asst1-src/kern/compile/ASST3
+
+
+target remote localhost:16161
+b panic
+end
diff --git root_config/sys161-asst2.conf root_config/sys161-asst2.conf
new file mode 100644
index 0000000..76dc550
--- /dev/null
+++ root_config/sys161-asst2.conf
@@ -0,0 +1,136 @@
+# Sample sys161.conf file
+#
+# This file tells System/161 what devices to use.
+#
+# There are 32 LAMEbus slots on the System/161 motherboard. There may
+# be only one bus controller card, and it must go in slot 31. Other
+# than that, you can put in whatever devices you want.
+#
+# The syntax is simple: one slot per line; the slot number goes first,
+# then the expansion card name, then any arguments. Some of the devices
+# have required arguments.
+#
+# The devices are:
+#
+#   mainboard The multiprocessor LAMEbus controller card. Must go in
+#             slot 31, and only in slot 31. Required argument
+#             "ramsize=NUMBER" specifies the amount of physical RAM in
+#             the system. This amount must be a multiple of the
+#             hardware page size (which is probably 4096 or 8192.) The
+#             maximum amount of RAM allowed is 16M; this restriction
+#             is meant as a sanity check and can be altered by
+#             recompiling System/161. The argument "cpus=NUMBER"
+#             selects the number of CPUs; the default is 1 and the
+#             maximum 32.
+#
+#   oldmainboard  The uniprocessor LAMEbus controller card, fully
+#             backwards compatible with OS/161 1.x. In general,
+#             uniprocessor kernels should nonetheless work on the
+#             multiprocessor mainboard; therefore this device will
+#             probably be removed in the future. Configuration is the
+#             same as the multiprocessor mainboard, except that the
+#             "cpus" argument is not accepted. The OS/161 1.x name
+#             "busctl" is an alias for "oldmainboard".
+#
+#   trace     The System/161 trace controller device. This can be used
+#             by software for various debugging purposes. You can have
+#             more than one trace card, but they all manipulate the
+#             same internal state. No arguments.
+#
+#   timer     Countdown timer. The timer card also contains a real-time
+#             clock and a small speaker for beeping. Most configurations
+#             will include at least one timer. No arguments.
+#
+#   serial    Serial port. This is connected to the standard input and
+#             standard output of the System/161 process, and serves as
+#             the system console. Most configurations need this. There
+#             is no support at present for more than one serial port.
+#             No arguments.
+#
+#   screen    Full-screen memory-mapped text video card. This is
+#             connected to the standard input and standard output of
+#             the System/161 process, and serves as the system console.
+#             There is no support at present for more than one screen.
+#             Likewise, at present you may not use "screen" and "serial"
+#             together. No arguments. NOTE: not presently implemented.
+#
+#   random    (Pseudo-)random number generator. This accesses the
+#             randomizer state within System/161; thus, while you can
+#             add multiple random cards, they all return values from the
+#             same pseudorandom sequence. The random seed is set by
+#             using either the "seed=NUMBER" argument, which sets the
+#             random seed to a specified value, or the "autoseed"
+#             argument, which sets the random seed based on the host
+#             system clock. If neither argument is given or no random
+#             device is used, the seed is set to 0. Note that the seed
+#             affects various randomized behavior of the system as well
+#             as the values provided by the random device.
+#
+#   disk      Fixed disk. The options are as follows:
+#                 rpm=NUMBER         Set spin rate of disk.
+#                 sectors=NUMBER     Set disk size. Each sector is 512 bytes.
+#                 file=PATH          Specify file to use as storage for disk.
+#                 paranoid           Set paranoid mode.
+#
+#             The "file=PATH" argument must be supplied. The size must be
+#             at least 128 sectors (64k), and the RPM setting must be a
+#             multiple of 60.
+#
+#             The "paranoid" argument, if given, causes fsync() to be
+#             called on every disk write to make sure the data written
+#             reaches actual stable storage. This will make things very
+#             slow.
+#
+#             You can have as many disks as you want (until you run out
+#             of slots) but each should have a distinct file to use for
+#             storage. Most common setups will use two separate disks,
+#             one for filesystem storage and one for swapping.
+#
+#   nic       Network card. This allows communication among multiple
+#             simultaneously-running copies of System/161. The arguments
+#             are:
+#                 hub=PATH           Give the path to the hub socket.
+#                 hwaddr=NUMBER      Specify the hardware-level card address.
+#
+#             The hub socket path should be the argument supplied to the
+#             hub161 program. The default is ".sockets/hub".
+#
+#             The hardware address should be unique among the systems
+#             connected to the same hub. It should be an integer between
+#             1 and 65534. Values 0 and 65535 are reserved for special
+#             purposes. This argument is required.
+#
+#             NOTE: disable (comment out) nic devices if you aren't
+#             actively using them, to avoid unnecessary overhead.
+#
+#   emufs     Emulator filesystem. This provides access *within*
+#             System/161 to the filesystem that System/161 is running
+#             in. There is one optional argument, "dir=PATH". The path
+#             specified is used as the root of the filesystem provided
+#             by emufs. (Note that it is possible to access the real
+#             parent of this root and thus any other directory; this
+#             argument does not restrict access.) The default path is
+#             ".", meaning System/161's own current directory.
+#
+
+#
+# Here is a suggested default configuration: 512k RAM, two 5M disks.
+#
+
+0   serial
+#0  screen
+
+1   emufs
+
+2   disk    rpm=7200    sectors=10240   file=DISK1.img
+3   disk    rpm=7200    sectors=10240   file=DISK2.img
+
+#27 nic hwaddr=1
+
+28  random  autoseed
+29  timer
+30  trace
+31  mainboard  ramsize=16777216  cpus=1
+#31 mainboard  ramsize=524288  cpus=2
+#31 mainboard  ramsize=524288  cpus=4
+
diff --git userland/testbin/asst2/Makefile userland/testbin/asst2/Makefile
index 448603d..affe816 100644
--- userland/testbin/asst2/Makefile
+++ userland/testbin/asst2/Makefile
@@ -4,7 +4,7 @@ TOP=../../..
 .include "$(TOP)/mk/os161.config.mk"
 
 PROG=asst2
-SRCS=asst2.c
+SRCS=asst2.c ./file_unittest.c
 BINDIR=/testbin
 
 .include "$(TOP)/mk/os161.prog.mk"
diff --git userland/testbin/asst2/asst2.c userland/testbin/asst2/asst2.c
index fe27a2f..5c8cffe 100644
--- userland/testbin/asst2/asst2.c
+++ userland/testbin/asst2/asst2.c
@@ -8,121 +8,122 @@
 #include <errno.h>
 
 #define MAX_BUF 500
-char teststr[] = "The quick brown fox jumped over the lazy dog.";
-char buf[MAX_BUF];
-
+/* char teststr[] = "The quick brown fox jumped over the lazy dog."; */
+/* char buf[MAX_BUF]; */
+void file_unittest(void);
 int
-main(int argc, char * argv[])
+main()
 {
-        int fd, r, i, j , k;
-        (void) argc;
-        (void) argv;
-
-        printf("\n**********\n* File Tester\n");
-
-        snprintf(buf, MAX_BUF, "**********\n* write() works for stdout\n");
-        write(1, buf, strlen(buf));
-        snprintf(buf, MAX_BUF, "**********\n* write() works for stderr\n");
-        write(2, buf, strlen(buf));
-
-        printf("**********\n* opening new file \"test.file\"\n");
-        fd = open("test.file", O_RDWR | O_CREAT );
-        printf("* open() got fd %d\n", fd);
-        if (fd < 0) {
-                printf("ERROR opening file: %s\n", strerror(errno));
-                exit(1);
-        }
-
-        printf("* writing test string\n");
-        r = write(fd, teststr, strlen(teststr));
-        printf("* wrote %d bytes\n", r);
-        if (r < 0) {
-                printf("ERROR writing file: %s\n", strerror(errno));
-                exit(1);
-        }
-
-        printf("* writing test string again\n");
-        r = write(fd, teststr, strlen(teststr));
-        printf("* wrote %d bytes\n", r);
-        if (r < 0) {
-                printf("ERROR writing file: %s\n", strerror(errno));
-                exit(1);
-        }
-        printf("* closing file\n");
-        close(fd);
-
-        printf("**********\n* opening old file \"test.file\"\n");
-        fd = open("test.file", O_RDONLY);
-        printf("* open() got fd %d\n", fd);
-        if (fd < 0) {
-                printf("ERROR opening file: %s\n", strerror(errno));
-                exit(1);
-        }
-
-        printf("* reading entire file into buffer \n");
-        i = 0;
-        do  {
-                printf("* attemping read of %d bytes\n", MAX_BUF -i);
-                r = read(fd, &buf[i], MAX_BUF - i);
-                printf("* read %d bytes\n", r);
-                i += r;
-        } while (i < MAX_BUF && r > 0);
-
-        printf("* reading complete\n");
-        if (r < 0) {
-                printf("ERROR reading file: %s\n", strerror(errno));
-                exit(1);
-        }
-        k = j = 0;
-        r = strlen(teststr);
-        do {
-                if (buf[k] != teststr[j]) {
-                        printf("ERROR  file contents mismatch\n");
-                        exit(1);
-                }
-                k++;
-                j = k % r;
-        } while (k < i);
-        printf("* file content okay\n");
-
-        printf("**********\n* testing lseek\n");
-        r = lseek(fd, 5, SEEK_SET);
-        if (r < 0) {
-                printf("ERROR lseek: %s\n", strerror(errno));
-                exit(1);
-        }
-
-        printf("* reading 10 bytes of file into buffer \n");
-        i = 0;
-        do  {
-                printf("* attemping read of %d bytes\n", 10 - i );
-                r = read(fd, &buf[i], 10 - i);
-                printf("* read %d bytes\n", r);
-                i += r;
-        } while (i < 10 && r > 0);
-        printf("* reading complete\n");
-        if (r < 0) {
-                printf("ERROR reading file: %s\n", strerror(errno));
-                exit(1);
-        }
-
-        k = 0;
-        j = 5;
-        r = strlen(teststr);
-        do {
-                if (buf[k] != teststr[j]) {
-                        printf("ERROR  file contents mismatch\n");
-                        exit(1);
-                }
-                k++;
-                j = (k + 5)% r;
-        } while (k < 5);
-
-        printf("* file lseek  okay\n");
-        printf("* closing file\n");
-        close(fd);
-
-        return 0;
+    file_unittest();
+	/* int fd, r, i, j , k; */
+	/* (void) argc; */
+	/* (void) argv; */
+    /*  */
+	/* printf("\n**********\n* File Tester\n"); */
+    /*  */
+	/* snprintf(buf, MAX_BUF, "**********\n* write() works for stdout\n"); */
+	/* write(1, buf, strlen(buf)); */
+	/* snprintf(buf, MAX_BUF, "**********\n* write() works for stderr\n"); */
+	/* write(2, buf, strlen(buf)); */
+    /*  */
+	/* printf("**********\n* opening new file \"test.file\"\n"); */
+	/* fd = open("test.file", O_RDWR | O_CREAT ); */
+	/* printf("* open() got fd %d\n", fd); */
+	/* if (fd < 0) { */
+	/* 	printf("ERROR opening file: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+    /*  */
+	/* printf("* writing test string\n"); */
+	/* r = write(fd, teststr, strlen(teststr)); */
+	/* printf("* wrote %d bytes\n", r); */
+	/* if (r < 0) { */
+	/* 	printf("ERROR writing file: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+    /*  */
+	/* printf("* writing test string again\n"); */
+	/* r = write(fd, teststr, strlen(teststr)); */
+	/* printf("* wrote %d bytes\n", r); */
+	/* if (r < 0) { */
+	/* 	printf("ERROR writing file: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+	/* printf("* closing file\n"); */
+	/* close(fd); */
+    /*  */
+	/* printf("**********\n* opening old file \"test.file\"\n"); */
+	/* fd = open("test.file", O_RDONLY); */
+	/* printf("* open() got fd %d\n", fd); */
+	/* if (fd < 0) { */
+	/* 	printf("ERROR opening file: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+    /*  */
+	/* printf("* reading entire file into buffer \n"); */
+	/* i = 0; */
+	/* do  { */
+	/* 	printf("* attemping read of %d bytes\n", MAX_BUF -i); */
+	/* 	r = read(fd, &buf[i], MAX_BUF - i); */
+	/* 	printf("* read %d bytes\n", r); */
+	/* 	i += r; */
+	/* } while (i < MAX_BUF && r > 0); */
+    /*  */
+	/* printf("* reading complete\n"); */
+	/* if (r < 0) { */
+	/* 	printf("ERROR reading file: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+	/* k = j = 0; */
+	/* r = strlen(teststr); */
+	/* do { */
+	/* 	if (buf[k] != teststr[j]) { */
+	/* 		printf("ERROR  file contents mismatch\n"); */
+	/* 		exit(1); */
+	/* 	} */
+	/* 	k++; */
+	/* 	j = k % r; */
+	/* } while (k < i); */
+	/* printf("* file content okay\n"); */
+    /*  */
+	/* printf("**********\n* testing lseek\n"); */
+	/* r = lseek(fd, 5, SEEK_SET); */
+	/* if (r < 0) { */
+	/* 	printf("ERROR lseek: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+    /*  */
+	/* printf("* reading 10 bytes of file into buffer \n"); */
+	/* i = 0; */
+	/* do  { */
+	/* 	printf("* attemping read of %d bytes\n", 10 - i ); */
+	/* 	r = read(fd, &buf[i], 10 - i); */
+	/* 	printf("* read %d bytes\n", r); */
+	/* 	i += r; */
+	/* } while (i < 10 && r > 0); */
+	/* printf("* reading complete\n"); */
+	/* if (r < 0) { */
+	/* 	printf("ERROR reading file: %s\n", strerror(errno)); */
+	/* 	exit(1); */
+	/* } */
+    /*  */
+	/* k = 0; */
+	/* j = 5; */
+	/* r = strlen(teststr); */
+	/* do { */
+	/* 	if (buf[k] != teststr[j]) { */
+	/* 		printf("ERROR  file contents mismatch\n"); */
+	/* 		exit(1); */
+	/* 	} */
+	/* 	k++; */
+	/* 	j = (k + 5)% r; */
+	/* } while (k < 5); */
+    /*  */
+	/* printf("* file lseek  okay\n"); */
+	/* printf("* closing file\n"); */
+	/* close(fd); */
+
+	return 0;
 }
 
 
diff --git userland/testbin/asst2/file_unittest.c userland/testbin/asst2/file_unittest.c
new file mode 100644
index 0000000..a9085f3
--- /dev/null
+++ userland/testbin/asst2/file_unittest.c
@@ -0,0 +1,684 @@
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <err.h>
+#include <errno.h>
+#define MAX_FDNUM_PER_PROCESS 128
+
+#define NONE                 "\e[0m"
+#define BLACK                "\e[0;30m"
+#define L_BLACK              "\e[1;30m"
+#define RED                  "\e[0;31m"
+#define L_RED                "\e[1;31m"
+#define GREEN                "\e[0;32m"
+#define L_GREEN              "\e[1;32m"
+#define BROWN                "\e[0;33m"
+#define YELLOW               "\e[1;33m"
+#define BLUE                 "\e[0;34m"
+#define L_BLUE               "\e[1;34m"
+#define PURPLE               "\e[0;35m"
+#define L_PURPLE             "\e[1;35m"
+#define CYAN                 "\e[0;36m"
+#define L_CYAN               "\e[1;36m"
+#define GRAY                 "\e[0;37m"
+#define WHITE                "\e[1;37m"
+
+#define BOLD                 "\e[1m"
+#define UNDERLINE            "\e[4m"
+#define BLINK                "\e[5m"
+#define REVERSE              "\e[7m"
+#define HIDE                 "\e[8m"
+#define CLEAR                "\e[2J"
+#define CLRLINE              "\r\e[K" //or "\e[1K\r"
+
+void file_unittest(void);
+static int pass_count = 0;
+static int total_count = 0;
+
+static int fail_count = 0;
+
+static char buf[100000] = {0};
+static int buf_len  = 0;
+
+#define TASSERT(expr, v) do {\
+    if (!(expr)) \
+    {\
+        printf( CYAN "\n################TASSERT ############\n ");\
+        write(1, __FILE__, sizeof(__FILE__));\
+        write(1, "(",1 );\
+        printf("%d", (int)__LINE__);\
+        write(1, "):",2 );\
+        write(1, __func__, sizeof(__func__));\
+        write(1, "--------->", 10);\
+        write(1, #expr, sizeof(#expr)); \
+        printf(", but value is %d  ", (int)v);\
+        write(1, "\n--->", 5);\
+        printf("errno : %d, msg: %s\n" NONE , errno, strerror(errno));\
+        return -1;\
+    }\
+}while(0)
+
+
+#define FUNCTION_CALL(func, args...) do{\
+    int tmp = 0;\
+    printf (YELLOW "\nrunning: %s\n" NONE, #func);\
+    tmp = func(args);\
+    (tmp == 0) ? (pass_count ++ ): (fail_count ++);\
+    total_count ++;\
+    if (tmp == 0) {\
+        printf (GREEN "%s passed\n" NONE, #func);\
+    } else {\
+        printf (RED "%s failed\n" NONE, #func);\
+    }\
+} while(0)
+
+#define BEGIN_FUNCTION {}
+#define END_FUNCTION return 0
+
+
+static int random_generator()
+{
+    time_t tt;
+    time(&tt);
+    /* printf ("time: %lld\n", tt); */
+    srandom(tt);
+    /* printf ("random: %ld\n", random()); */
+    return (int)(random());
+
+}
+static char* random_str_generator()
+{
+    static char tmp[20] = {0};
+    int r = random_generator();
+    int len = snprintf(tmp, 19, "%d", r);
+    tmp[len] = 0;
+    return tmp;
+
+}
+static int test_readonly(int a, int b)
+{
+    int ret =  0;
+    a = 3;
+    b = 5;
+    TASSERT(a !=b , 0);
+    int fd = open("tp_tr", O_RDONLY| O_CREAT);
+    TASSERT(fd >= 0, fd);
+    ret = read(fd, buf, 100);
+    TASSERT(ret >= 0, ret);
+    ret = write(fd, "w1", 2);
+    TASSERT(ret == -1, ret);
+    TASSERT(close(fd) == 0, 0);
+    return 0;
+}
+static int test_writeonly()
+{
+    int ret =  0;
+    int fd = open("tp_tw", O_WRONLY| O_CREAT);
+    TASSERT(fd >= 0, fd);
+    ret = read(fd, buf, 100);
+    TASSERT(ret == -1, ret);
+    ret = write(fd, "w1", 2);
+    TASSERT(ret == 2, 2);
+    TASSERT(close(fd) == 0, 0);
+    return 0;
+
+}
+static int test_readandwrite(void)
+{
+    int ret =  0;
+    int fd = open("tp_raw", O_RDWR| O_CREAT);
+    TASSERT(fd >= 0, fd);
+    ret = read(fd, buf, 100);
+    TASSERT(ret >= 0, ret);
+    ret = write(fd, "w1", 2);
+    TASSERT(ret == 2, ret);
+    TASSERT(close(fd) == 0, 0);
+    return 0;
+}
+
+static int test_create_flag(void)
+{
+    char file_name[30] = {0};
+    int len = snprintf(file_name, 29, "test_create_flag_%s", random_str_generator());
+    file_name[len] = 0;
+    printf ("create file: %s\n", file_name);
+    int fd = open(file_name, 0);
+    TASSERT(fd == -1, fd);
+    TASSERT(errno == ENOENT, errno);
+    fd = open(file_name, O_CREAT);
+    TASSERT(fd >= 3, fd);
+    TASSERT(close(fd) == 0, 0);
+    return 0;
+}
+static int test_excl_flag(void)
+{
+    BEGIN_FUNCTION;
+    char file_name[30] = {0};
+    int len = snprintf(file_name, 29, "test_excl_flag_%s", random_str_generator());
+    file_name[len] = 0;
+    printf ("file: %s\n", file_name);
+    int fd = open(file_name, O_EXCL);
+    TASSERT(fd == -1, fd);
+
+    fd = open(file_name, O_EXCL|O_CREAT);
+    TASSERT(fd >= 3, fd);
+    close(fd);
+
+    fd = open(file_name, O_EXCL|O_CREAT);
+    TASSERT(fd == -1, fd);
+    TASSERT(errno  == EEXIST, errno);
+
+    fd = open(file_name, O_CREAT);
+    TASSERT(fd >=3 , fd);
+    close(fd);
+    END_FUNCTION;
+}
+static int test_invalid_close(void)
+{
+    BEGIN_FUNCTION;
+    int ret = close(339);
+    TASSERT(errno == EBADF, errno);
+    TASSERT(ret == -1, ret);
+
+    ret = close(-1);
+    TASSERT(errno == EBADF, errno);
+    TASSERT(ret == -1, ret);
+
+    END_FUNCTION;
+}
+static int test_invalid_dup2(void)
+{
+    BEGIN_FUNCTION;
+    int ret = 0;
+    /* int fd = open("test_invalid_dup2", O_CREAT|O_RDWR); */
+    ret = dup2(100, 101);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+    ret = dup2(100, 1);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+    /* ret = dup2(1, 100); */
+    /* TASSERT(ret == -1, ret); */
+    /* TASSERT(errno == EBADF, errno); */
+
+
+    END_FUNCTION;
+}
+static int test_dup2_to_file(void)
+{
+    char buf[20];
+    int buf_len = 20;
+    BEGIN_FUNCTION;
+    int fd = open("test_dup2_to_file", O_CREAT|O_RDWR|O_TRUNC);
+    TASSERT(fd >= 0, fd);
+    int ret = dup2(2, 100);
+    TASSERT(ret >= 0, ret);
+    ret = dup2(fd, 2);
+    TASSERT(ret >= 0, ret);
+
+    ret = write(2, "hello", 5);
+    TASSERT(ret == 5, ret);
+
+    lseek(2, 0, SEEK_SET);
+    ret = read(2, buf, buf_len);
+    TASSERT(ret == 5, ret);
+
+    lseek(fd, 0, SEEK_SET);
+    ret = read(fd, buf, buf_len);
+    TASSERT(ret == 5, ret);
+
+    close(2);
+
+    lseek(fd, 0, SEEK_SET);
+    ret = read(fd, buf, buf_len);
+    TASSERT(ret == 5, ret);
+
+    lseek(2, 0, SEEK_SET);
+    ret = read(2, buf, buf_len);
+    TASSERT(ret == -1, ret);
+
+
+    ret = dup2(100, 2);
+    TASSERT(ret >= 0, ret);
+    ret = close(100);
+    TASSERT(ret>= 0, ret);
+
+    ret = close(fd);
+    TASSERT(ret >= 0, ret);
+    END_FUNCTION;
+}
+static int test_dup2_to_stdio(void)
+{
+    BEGIN_FUNCTION;
+
+    int ret = dup2(2, 100);
+    TASSERT(ret == 0, ret);
+
+    ret = write(100, RED "should be seen, 1!!\n" NONE, 20 + strlen(RED) + strlen(NONE));
+    TASSERT(ret > 0 , ret);
+    ret = close(100);
+    TASSERT(ret == 0, ret);
+
+    ret = write(2, RED "should be seen, 2!!\n" NONE, 20 + strlen(RED) + strlen(NONE));
+    TASSERT(ret > 0 , ret);
+
+    ret = write(100, RED "should not be seen, 1!!\n" NONE, 24 + strlen(RED) + strlen(NONE));
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+
+    int fd = open ("test_dup2_to_stdio", O_CREAT|O_RDWR);
+    TASSERT(fd >= 3, fd);
+    ret = write(fd, "hello\n", 6);
+    TASSERT(ret == 6, ret);
+    ret = dup2(2, fd);
+    ret = write(fd, RED "should be seen, 3!!\n" NONE, 20 + strlen(RED) + strlen(NONE));
+    TASSERT(ret > 0, ret );
+
+    close(fd);
+    ret = write(fd, RED "should not be seen, 2!!\n" NONE, 24 + strlen(RED) + strlen(NONE));
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+    ret = write(2, RED "should be seen, 4!!\n" NONE, 20 + strlen(RED) + strlen(NONE));
+    TASSERT(ret > 0, ret);
+
+    END_FUNCTION;
+}
+static int test_valid_close(void)
+{
+    BEGIN_FUNCTION;
+    int ret = 0;
+    ret = close(0);
+    TASSERT(ret == 0,ret);
+    ret = close(2);
+    TASSERT(ret == 0, ret);
+
+    ret = write(2, RED "should not seen!!\n" NONE, 20 + strlen(RED) + strlen(NONE));
+    TASSERT(ret < 0, ret);
+
+    int fd = open ("test_valid_close", O_CREAT);
+    ret = close(fd);
+
+
+    END_FUNCTION;
+}
+static int test_limited_open_fd(void)
+{
+    BEGIN_FUNCTION;
+    int ret = 0;
+    /*
+     * 128 is the upper limit, 0, 1, 2 is for stdio, so there are still 125 fd could be used in
+     * one process
+     * but the lower fs may support less than 128
+     */
+    int fd = 0 ;
+    int upper_fd = 0;
+    for (int i = 3; i < MAX_FDNUM_PER_PROCESS + 1; i ++)
+    {
+        fd = open("test_limited_open_fd", O_CREAT);
+        if (fd != -1)
+        {
+
+            TASSERT(fd == i, i);
+            upper_fd = i;
+        }
+        else
+        {
+            TASSERT(fd == -1, fd);
+            TASSERT(errno, ENFILE);
+            upper_fd = i;
+            break;
+        }
+    }
+    printf ("max fd num is: %d, the limited is %d\n", upper_fd, MAX_FDNUM_PER_PROCESS);
+
+    fd = open("test_limited_open_fd", O_CREAT);
+    TASSERT(fd == -1, fd);
+    /* TASSERT(errno == EMFILE, errno); */
+
+    for (int i = 3; i < upper_fd; i ++)
+    {
+        ret = close(i);
+        TASSERT(ret == 0, ret);
+    }
+    END_FUNCTION;
+}
+
+static int test_iterative_close(void)
+{
+    BEGIN_FUNCTION;
+    for (int i = 3; i < MAX_FDNUM_PER_PROCESS; i ++)
+    {
+        printf ("close fd: %d\n" ,i);
+        int ret = close(i);
+        TASSERT(ret == -1, ret);
+        TASSERT(errno == EBADF, errno);
+    }
+    END_FUNCTION;
+}
+static int test_iterative_dup2(void)
+{
+    BEGIN_FUNCTION;
+    int ret = 0;
+    for (int i = 3; i < MAX_FDNUM_PER_PROCESS; i ++)
+    {
+        ret = dup2(1, i);
+        TASSERT(ret == 0, ret);
+    }
+    ret = dup2( 1, MAX_FDNUM_PER_PROCESS );
+    TASSERT(ret == -1, ret);
+
+    for (int i = 3; i < MAX_FDNUM_PER_PROCESS; i ++)
+    {
+        ret = close(i);
+        TASSERT(ret == 0, ret);
+    }
+
+    END_FUNCTION;
+
+}
+static void test_permission(void)
+{
+    FUNCTION_CALL(test_readonly, 1, 2);
+    FUNCTION_CALL(test_writeonly);
+    FUNCTION_CALL(test_readandwrite);
+    return;
+}
+static void test_other_open_flag()
+{
+    FUNCTION_CALL(test_create_flag);
+    FUNCTION_CALL(test_excl_flag);
+    return;
+}
+
+static void test_close()
+{
+    FUNCTION_CALL(test_iterative_close);
+    FUNCTION_CALL(test_invalid_close);
+    FUNCTION_CALL(test_valid_close);
+    return;
+}
+static void test_dup2()
+{
+    FUNCTION_CALL(test_invalid_dup2);
+    FUNCTION_CALL(test_dup2_to_stdio);
+    FUNCTION_CALL(test_dup2_to_file);
+    FUNCTION_CALL(test_iterative_dup2);
+    /* FUNCTION_CALL(test_dup2_to_file); */
+
+    return;
+}
+
+
+static void test_open(void)
+{
+    test_permission();
+    test_other_open_flag();
+    FUNCTION_CALL(test_limited_open_fd);
+    return;
+
+
+}
+
+
+static int test_invalid_lseek(void)
+{
+    BEGIN_FUNCTION;
+    int ret = 0;
+    ret = lseek(1, 100, SEEK_SET);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == ESPIPE, errno);
+
+    ret = lseek(0, 12, SEEK_END);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == ESPIPE, errno);
+
+    ret = lseek(2, 121, SEEK_CUR);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == ESPIPE, errno);
+
+
+    ret = lseek(3, 12, SEEK_SET);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+    int fd = open("test_invalid_lseek", O_CREAT|O_RDWR|O_TRUNC);
+    TASSERT(fd == 3, fd);
+
+    ret = lseek(3, 101, 3);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EINVAL, errno);
+
+    ret = lseek(3, 1213, -1);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EINVAL, errno);
+
+    ret = lseek(3, -123432, SEEK_SET);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EINVAL, errno);
+
+    ret = lseek(3, 10, SEEK_SET);
+    TASSERT(ret == 10, ret);
+
+    ret = lseek(3, -11, SEEK_CUR);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EINVAL, errno);
+
+    ret = lseek(3, 0, SEEK_SET);
+    ret = write(3, "hello", 5);
+    TASSERT(ret == 5, ret);
+
+    ret = lseek(3, -6, SEEK_END);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EINVAL, errno);
+
+
+    close(3);
+
+    END_FUNCTION;
+}
+
+int test_valid_lseek(void);
+int test_valid_lseek(void)
+{
+    BEGIN_FUNCTION;
+    off_t ret = 0;
+    int fd = open("test_valid_lseek", O_CREAT|O_TRUNC|O_RDWR);
+    TASSERT(fd == 3, fd);
+
+    ret = lseek(fd, 30000000000LL, SEEK_SET);
+    /* printf ("lseek pos: %lld\n", ret); */
+    TASSERT(ret == 30000000000LL, ret);
+
+    ret = lseek(fd, 20000000000LL, SEEK_CUR);
+    TASSERT(ret == 50000000000LL, ret);
+
+    ret = lseek(fd, -40000000000LL, SEEK_CUR);
+    TASSERT(ret == 10000000000LL, ret);
+
+    ret = lseek(fd, -40000000000LL, SEEK_CUR);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EINVAL, errno);
+
+
+    ret = lseek(fd, -10000000000LL, SEEK_CUR);
+    TASSERT(ret == 0, ret);
+
+    ret = lseek(fd,  5, SEEK_END);
+    TASSERT(ret == 5, ret);
+
+    ret = lseek(fd, 10000000000LL, SEEK_SET);
+    TASSERT(ret == 10000000000LL, ret);
+
+    ret = lseek(fd, 0, SEEK_CUR);
+    TASSERT(ret == 10000000000LL, ret);
+
+    close(3);
+    END_FUNCTION;
+}
+
+static void test_lseek(void)
+{
+
+    FUNCTION_CALL(test_invalid_lseek);
+    FUNCTION_CALL(test_valid_lseek);
+    return;
+
+}
+
+static int test_write(void)
+{
+    (void) buf_len;
+    int fd = open("test_write", O_RDWR|O_CREAT|O_TRUNC);
+    TASSERT(fd >= 3, fd);
+
+    int ret = write(fd, "hello world", 11);
+    TASSERT(ret == 11, ret);
+
+    TASSERT(lseek(fd, 0, SEEK_SET) == 0, 0);
+    ret = read(fd, buf, 100);
+    TASSERT(ret == 11, ret);
+    buf[ret] = 0;
+    TASSERT(strcmp(buf, "hello world" ) == 0, 0);
+
+
+    TASSERT(lseek(fd, 1000, SEEK_SET) == 1000, 0);
+
+    ret = write(fd, "hello world", 11);
+    TASSERT(ret == 11, ret);
+    TASSERT(lseek(fd, 1000, SEEK_SET) == 1000, 0);
+    ret = read(fd, buf, 100);
+    TASSERT(ret == 11, ret);
+    buf[ret] = 0;
+    TASSERT(strcmp(buf, "hello world" ) == 0, 0);
+
+    close(fd);
+
+    return 0;
+}
+static int test_invalid_read(void)
+{
+    BEGIN_FUNCTION;
+    int ret = read(19, buf, 5);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+    int fd = open ("test_invalid_read", O_CREAT|O_RDWR|O_TRUNC);
+    TASSERT(fd>=3, fd);
+
+    write(fd, "1", 1);
+    lseek(fd, 0, SEEK_SET);
+    char *p = (char *)0x131;
+    ret = read(fd, p, 5);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EFAULT, errno);
+
+    printf ("close fd: %d\n" , fd);
+    close(fd);
+
+    ret = read(1, buf, 1);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+
+    END_FUNCTION;
+
+}
+static int test_invalid_write(void)
+{
+    BEGIN_FUNCTION;
+    int ret = write(19, "hello", 5);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF, errno);
+
+    int fd = open ("test_invalid_write", O_CREAT|O_RDWR|O_TRUNC);
+    TASSERT(fd>=3, fd);
+
+    ret = write(fd, 0x0, 5);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EFAULT, errno);
+
+    close(fd);
+
+    ret = write(0, "h", 1);
+    TASSERT(ret == -1, ret);
+    TASSERT(errno == EBADF , errno);
+
+
+    END_FUNCTION;
+
+}
+static int test_sparse_file(void)
+{
+    BEGIN_FUNCTION;
+    int ret = 0;
+    int fd = open ("test_sparse_file", O_CREAT|O_RDWR|O_TRUNC);
+    TASSERT(fd>=3, fd);
+    TASSERT(lseek(fd, 10000, SEEK_SET) == 10000, 10000);
+
+    ret = write(fd, "sparse1", 7);
+    TASSERT(ret == 7, ret);
+    TASSERT(lseek(fd, 0, SEEK_SET) == 0, 0);
+
+    ret = read(fd, buf, sizeof(buf) - 1);
+    TASSERT(ret == (7 + 10000), ret);
+    TASSERT(buf[10001] == 'p', 'p');
+    close(fd);
+
+    END_FUNCTION;
+}
+
+static int test_iterative_write(void)
+{
+    BEGIN_FUNCTION;
+    int ret, fd;
+    fd = open("test_iterative_write", O_CREAT|O_RDWR|O_TRUNC);
+    for (int i = 0; i < 100; i ++)
+    {
+        ret = write(fd, "hello", 5);
+        TASSERT(ret == 5, ret);
+    }
+    lseek(fd, 0, SEEK_SET);
+    ret = read(fd, buf, 10000);
+    TASSERT(ret == 5 * 100, ret);
+    close(fd);
+
+    END_FUNCTION;
+}
+
+static void test_read_write(void)
+{
+    FUNCTION_CALL(test_invalid_write);
+    FUNCTION_CALL(test_write);
+    FUNCTION_CALL(test_sparse_file);
+    FUNCTION_CALL(test_iterative_write);
+
+    FUNCTION_CALL(test_invalid_read);
+    return;
+}
+
+void file_unittest(void)
+{
+    printf ("\n\n####### start file unitest ########\n");
+    printf ("%s\n", random_str_generator());
+
+    test_dup2();
+    test_open();
+    /* test_open(); */
+
+    test_lseek();
+    test_read_write();
+
+    test_close();
+
+
+    printf ("\n####### end file unitest ########\n\n");
+    printf ("############## Statistic: Ran %d Test Case, %d Passed, %d Failed\n\n", total_count, pass_count, fail_count);
+    return;
+}
